<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mathter: mathter Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Mathter
   </div>
   <div id="projectbrief">A configurable 3D math library for game developers.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">mathter Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacemathter_1_1impl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemathter_1_1impl.html">impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemathter_1_1quat__literals"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemathter_1_1quat__literals.html">quat_literals</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemathter_1_1traits"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemathter_1_1traits.html">traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmathter_1_1_approx_helper.html">ApproxHelper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmathter_1_1_bezier_curve.html">BezierCurve</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmathter_1_1_constants.html">Constants</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accurate mathematical constants.  <a href="classmathter_1_1_constants.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmathter_1_1_decomposition_l_u.html">DecompositionLU</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility class that can do common operations with the LU decomposition, i.e. solving equation systems.  <a href="classmathter_1_1_decomposition_l_u.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmathter_1_1_decomposition_l_u_p.html">DecompositionLUP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility class that can do common operations with the LUP decomposition, i.e. solving equation systems.  <a href="classmathter_1_1_decomposition_l_u_p.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmathter_1_1_decomposition_q_r.html">DecompositionQR</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility class that can do common operations with the QR decomposition, i.e. solving equation systems.  <a href="classmathter_1_1_decomposition_q_r.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmathter_1_1_decomposition_s_v_d.html">DecompositionSVD</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility class that can do common operations with the singular value decomposition, i.e. solving equation systems.  <a href="classmathter_1_1_decomposition_s_v_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmathter_1_1_hyperplane.html">Hyperplane</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmathter_1_1_identity_builder.html">IdentityBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmathter_1_1_intersection.html">Intersection</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmathter_1_1_intersection_3_01_hyperplane_3_01_t_00_012_01_4_00_01_hyperplane_3_01_t_00_012_01_4_01_4.html">Intersection&lt; Hyperplane&lt; T, 2 &gt;, Hyperplane&lt; T, 2 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmathter_1_1_intersection_3_01_hyperplane_3_01_t_00_01_dim_01_4_00_01_line_3_01_t_00_01_dim_01_4_01_4.html">Intersection&lt; Hyperplane&lt; T, Dim &gt;, Line&lt; T, Dim &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmathter_1_1_intersection_3_01_hyperplane_3_01_t_00_01_dim_01_4_00_01_line_segment_3_01_t_00_01_dim_01_4_01_4.html">Intersection&lt; Hyperplane&lt; T, Dim &gt;, LineSegment&lt; T, Dim &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmathter_1_1_intersection_3_01_line_3_01_t_00_012_01_4_00_01_line_3_01_t_00_012_01_4_01_4.html">Intersection&lt; Line&lt; T, 2 &gt;, Line&lt; T, 2 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmathter_1_1_intersection_3_01_line_3_01_t_00_012_01_4_00_01_line_segment_3_01_t_00_012_01_4_01_4.html">Intersection&lt; Line&lt; T, 2 &gt;, LineSegment&lt; T, 2 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmathter_1_1_intersection_3_01_line_3_01_t_00_01_dim_01_4_00_01_hyperplane_3_01_t_00_01_dim_01_4_01_4.html">Intersection&lt; Line&lt; T, Dim &gt;, Hyperplane&lt; T, Dim &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmathter_1_1_intersection_3_01_line_segment_3_01_t_00_012_01_4_00_01_line_3_01_t_00_012_01_4_01_4.html">Intersection&lt; LineSegment&lt; T, 2 &gt;, Line&lt; T, 2 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmathter_1_1_intersection_3_01_line_segment_3_01_t_00_012_01_4_00_01_line_segment_3_01_t_00_012_01_4_01_4.html">Intersection&lt; LineSegment&lt; T, 2 &gt;, LineSegment&lt; T, 2 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmathter_1_1_intersection_3_01_line_segment_3_01_t_00_01_dim_01_4_00_01_hyperplane_3_01_t_00_01_dim_01_4_01_4.html">Intersection&lt; LineSegment&lt; T, Dim &gt;, Hyperplane&lt; T, Dim &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmathter_1_1_intersection_3_01_ray_3_01_t_00_013_01_4_00_01_triangle3_d_3_01_t_01_4_01_4.html">Intersection&lt; Ray&lt; T, 3 &gt;, Triangle3D&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmathter_1_1_line.html">Line</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmathter_1_1_line_segment.html">LineSegment</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmathter_1_1_matrix.html">Matrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmathter_1_1_matrix_data.html">MatrixData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmathter_1_1_orthographic_builder.html">OrthographicBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmathter_1_1_perspective_builder.html">PerspectiveBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows you to do quaternion math and represent rotation in a compact way.  <a href="classmathter_1_1_quaternion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmathter_1_1_range_helper.html">RangeHelper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmathter_1_1_ray.html">Ray</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmathter_1_1_rotation2_d_builder.html">Rotation2DBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmathter_1_1_rotation3_d_axis_angle_builder.html">Rotation3DAxisAngleBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmathter_1_1_rotation3_d_axis_builder.html">Rotation3DAxisBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmathter_1_1_rotation3_d_tri_axis_builder.html">Rotation3DTriAxisBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmathter_1_1_scale_builder.html">ScaleBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmathter_1_1_shear_builder.html">ShearBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionmathter_1_1_simd.html">Simd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">2,4 or 8 dimension float or double parameters accepted. Uses SSE2 or AVX acceleration if enabled in the compiler.  <a href="unionmathter_1_1_simd.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionmathter_1_1_simd_3_01double_00_012_01_4.html">Simd&lt; double, 2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionmathter_1_1_simd_3_01double_00_014_01_4.html">Simd&lt; double, 4 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionmathter_1_1_simd_3_01float_00_014_01_4.html">Simd&lt; float, 4 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionmathter_1_1_simd_3_01float_00_018_01_4.html">Simd&lt; float, 8 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmathter_1_1_submatrix_helper.html">SubmatrixHelper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmathter_1_1_swizzle.html">Swizzle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables element swizzling (reordering elements) for vectors.  <a href="classmathter_1_1_swizzle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmathter_1_1_translation_builder.html">TranslationBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmathter_1_1_triangle3_d.html">Triangle3D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmathter_1_1_vector.html">Vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a vector in N-dimensional space.  <a href="classmathter_1_1_vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>VectorData</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>VectorData&lt; double, 2, false &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>VectorData&lt; double, 3, false &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>VectorData&lt; double, 4, false &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>VectorData&lt; float, 2, false &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>VectorData&lt; float, 3, false &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>VectorData&lt; float, 4, false &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>VectorData&lt; float, 8, false &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>VectorData&lt; T, 2, Packed &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>VectorData&lt; T, 3, Packed &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>VectorData&lt; T, 4, Packed &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmathter_1_1_view_builder.html">ViewBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmathter_1_1_zero_builder.html">ZeroBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a41e16685dc7a27ca3a59016e6cfcae32"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a41e16685dc7a27ca3a59016e6cfcae32">eMatrixOrder</a> { <a class="el" href="namespacemathter.html#a41e16685dc7a27ca3a59016e6cfcae32ae9c7f0ecfec845e853f09317db5857a3">eMatrixOrder::PRECEDE_VECTOR</a>, 
<a class="el" href="namespacemathter.html#a41e16685dc7a27ca3a59016e6cfcae32afa44321a5158c32f32558c8220df8353">eMatrixOrder::FOLLOW_VECTOR</a>
 }<tr class="memdesc:a41e16685dc7a27ca3a59016e6cfcae32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if you want to left- or right-multiply your matrices with vectors.  <a href="namespacemathter.html#a41e16685dc7a27ca3a59016e6cfcae32">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a41e16685dc7a27ca3a59016e6cfcae32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa43cfd54adea35fd8286213c5d198336"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemathter.html#aa43cfd54adea35fd8286213c5d198336">eMatrixLayout</a> { <a class="el" href="namespacemathter.html#aa43cfd54adea35fd8286213c5d198336a21541962976d7709c26e9cd8385bd648">eMatrixLayout::ROW_MAJOR</a>, 
<a class="el" href="namespacemathter.html#aa43cfd54adea35fd8286213c5d198336ada7520ed89bff27b02664af80951c6b0">eMatrixLayout::COLUMN_MAJOR</a>
 }<tr class="memdesc:aa43cfd54adea35fd8286213c5d198336"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the memory layout of matrices.  <a href="namespacemathter.html#aa43cfd54adea35fd8286213c5d198336">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:aa43cfd54adea35fd8286213c5d198336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5229d739adb6492fcb269f0168b72724"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a5229d739adb6492fcb269f0168b72724">eEnclosingBracket</a> { <a class="el" href="namespacemathter.html#a5229d739adb6492fcb269f0168b72724ab50339a10e1de285ac99d4c3990b8693">eEnclosingBracket::NONE</a>, 
<a class="el" href="namespacemathter.html#a5229d739adb6492fcb269f0168b72724a8fa806846c4d483f565b6fe5218baf7f">eEnclosingBracket::PARANTHESE</a>, 
<a class="el" href="namespacemathter.html#a5229d739adb6492fcb269f0168b72724a62c2198c66464d0dc1b231ef327c09fa">eEnclosingBracket::BRACKET</a>, 
<a class="el" href="namespacemathter.html#a5229d739adb6492fcb269f0168b72724aa978f79663129bdb1ab765185b15a9b2">eEnclosingBracket::BRACE</a>
 }</td></tr>
<tr class="separator:a5229d739adb6492fcb269f0168b72724"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3200e12d8fcb8d89f313a5423fbc7cde"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a3200e12d8fcb8d89f313a5423fbc7cde"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a3200e12d8fcb8d89f313a5423fbc7cde">AlmostEqual</a> (T d1, T d2, std::true_type)</td></tr>
<tr class="separator:a3200e12d8fcb8d89f313a5423fbc7cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a5d4c9078a598a4332e1b495a4462d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a94a5d4c9078a598a4332e1b495a4462d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a94a5d4c9078a598a4332e1b495a4462d">AlmostEqual</a> (T d1, T d2, std::false_type)</td></tr>
<tr class="separator:a94a5d4c9078a598a4332e1b495a4462d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a764cda941d47ce80c03dbd3206fb06f2"><td class="memTemplParams" colspan="2">template&lt;class T , class  = std::enable_if_t&lt;traits::NotVector&lt;T&gt;::value &amp;&amp; traits::NotMatrix&lt;T&gt;::value &amp;&amp; traits::NotQuaternion&lt;T&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a764cda941d47ce80c03dbd3206fb06f2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a764cda941d47ce80c03dbd3206fb06f2">AlmostEqual</a> (T d1, T d2)</td></tr>
<tr class="separator:a764cda941d47ce80c03dbd3206fb06f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f5d009b9c66bffba003ab295e99b2d9"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed1, bool Packed2&gt; </td></tr>
<tr class="memitem:a3f5d009b9c66bffba003ab295e99b2d9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a3f5d009b9c66bffba003ab295e99b2d9">AlmostEqual</a> (const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed1 &gt; &amp;lhs, const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed2 &gt; &amp;rhs)</td></tr>
<tr class="separator:a3f5d009b9c66bffba003ab295e99b2d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b113df0133920dcc9f934665ab33c8e"><td class="memTemplParams" colspan="2">template&lt;class T , bool Packed1, bool Packed2&gt; </td></tr>
<tr class="memitem:a0b113df0133920dcc9f934665ab33c8e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a0b113df0133920dcc9f934665ab33c8e">AlmostEqual</a> (const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed1 &gt; &amp;lhs, const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed2 &gt; &amp;rhs)</td></tr>
<tr class="separator:a0b113df0133920dcc9f934665ab33c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab322d8bbe8dc58339d2087c6aecb2b"><td class="memTemplParams" colspan="2">template&lt;class T , int Rows, int Columns, eMatrixOrder Order1, eMatrixLayout Layout1, bool Packed1, eMatrixOrder Order2, eMatrixLayout Layout2, bool Packed2&gt; </td></tr>
<tr class="memitem:abab322d8bbe8dc58339d2087c6aecb2b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#abab322d8bbe8dc58339d2087c6aecb2b">AlmostEqual</a> (const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order1, Layout1, Packed1 &gt; &amp;lhs, const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order2, Layout2, Packed2 &gt; &amp;rhs)</td></tr>
<tr class="separator:abab322d8bbe8dc58339d2087c6aecb2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90dd6a8246292c7a7199e84a1df53490"><td class="memTemplParams" colspan="2">template&lt;class LinalgClass1 , class LinalgClass2 &gt; </td></tr>
<tr class="memitem:a90dd6a8246292c7a7199e84a1df53490"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a90dd6a8246292c7a7199e84a1df53490">operator==</a> (const <a class="el" href="structmathter_1_1_approx_helper.html">ApproxHelper</a>&lt; LinalgClass1 &gt; &amp;lhs, const LinalgClass2 &amp;rhs)</td></tr>
<tr class="separator:a90dd6a8246292c7a7199e84a1df53490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cfcfc45f17be0679376e299482de97d"><td class="memTemplParams" colspan="2">template&lt;class LinalgClass1 , class LinalgClass2 &gt; </td></tr>
<tr class="memitem:a0cfcfc45f17be0679376e299482de97d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a0cfcfc45f17be0679376e299482de97d">operator==</a> (const LinalgClass1 &amp;lhs, const <a class="el" href="structmathter_1_1_approx_helper.html">ApproxHelper</a>&lt; LinalgClass2 &gt; &amp;rhs)</td></tr>
<tr class="separator:a0cfcfc45f17be0679376e299482de97d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbfd31d11f6e189ea855ca487c4b93f2"><td class="memTemplParams" colspan="2">template&lt;class LinalgClass1 , class LinalgClass2 &gt; </td></tr>
<tr class="memitem:afbfd31d11f6e189ea855ca487c4b93f2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#afbfd31d11f6e189ea855ca487c4b93f2">operator==</a> (const <a class="el" href="structmathter_1_1_approx_helper.html">ApproxHelper</a>&lt; LinalgClass1 &gt; &amp;lhs, const <a class="el" href="structmathter_1_1_approx_helper.html">ApproxHelper</a>&lt; LinalgClass2 &gt; &amp;rhs)</td></tr>
<tr class="separator:afbfd31d11f6e189ea855ca487c4b93f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b55f15ae8b41bf84889fc12f098b153"><td class="memTemplParams" colspan="2">template&lt;class LinalgClass &gt; </td></tr>
<tr class="memitem:a5b55f15ae8b41bf84889fc12f098b153"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a5b55f15ae8b41bf84889fc12f098b153">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structmathter_1_1_approx_helper.html">ApproxHelper</a>&lt; LinalgClass &gt; &amp;arg)</td></tr>
<tr class="separator:a5b55f15ae8b41bf84889fc12f098b153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7933ea57d631adcb3df6562ad0bb1bc"><td class="memTemplParams" colspan="2">template&lt;class LinalgClass &gt; </td></tr>
<tr class="memitem:ad7933ea57d631adcb3df6562ad0bb1bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmathter_1_1_approx_helper.html">ApproxHelper</a>&lt; LinalgClass &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#ad7933ea57d631adcb3df6562ad0bb1bc">ApproxVec</a> (const LinalgClass &amp;arg)</td></tr>
<tr class="separator:ad7933ea57d631adcb3df6562ad0bb1bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10bdf5eec755e23047fe581e2700ff54"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a10bdf5eec755e23047fe581e2700ff54"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_range_helper.html">RangeHelper</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a10bdf5eec755e23047fe581e2700ff54">Range</a> (T first, T last, T step)</td></tr>
<tr class="separator:a10bdf5eec755e23047fe581e2700ff54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7422073314358964a7b6456b6dbe2235"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a7422073314358964a7b6456b6dbe2235"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_range_helper.html">RangeHelper</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a7422073314358964a7b6456b6dbe2235">Range</a> (T first, T last)</td></tr>
<tr class="separator:a7422073314358964a7b6456b6dbe2235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af63bb811d15167408e7d288ca586ee65"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af63bb811d15167408e7d288ca586ee65"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_range_helper.html">RangeHelper</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#af63bb811d15167408e7d288ca586ee65">Range</a> (T last)</td></tr>
<tr class="separator:af63bb811d15167408e7d288ca586ee65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2110b681b7c68078f2f81ff186144d08"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, eMatrixOrder Order, eMatrixLayout Layout, bool Packed&gt; </td></tr>
<tr class="memitem:a2110b681b7c68078f2f81ff186144d08"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a2110b681b7c68078f2f81ff186144d08">DecomposeLU</a> (const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Dim, Dim, Order, Layout, Packed &gt; &amp;m)</td></tr>
<tr class="separator:a2110b681b7c68078f2f81ff186144d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a505330b72294388c562989458aa7c512"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, eMatrixOrder Order, eMatrixLayout Layout, bool Packed&gt; </td></tr>
<tr class="memitem:a505330b72294388c562989458aa7c512"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a505330b72294388c562989458aa7c512">DecomposeLUP</a> (const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Dim, Dim, Order, Layout, Packed &gt; &amp;m, int &amp;parity)</td></tr>
<tr class="memdesc:a505330b72294388c562989458aa7c512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements LU decomposition with partial pivoting.  <a href="#a505330b72294388c562989458aa7c512">More...</a><br /></td></tr>
<tr class="separator:a505330b72294388c562989458aa7c512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b93f1eecad5e31f23b17718c9371aaf"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, eMatrixOrder Order, eMatrixLayout Layout, bool Packed&gt; </td></tr>
<tr class="memitem:a7b93f1eecad5e31f23b17718c9371aaf"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a7b93f1eecad5e31f23b17718c9371aaf">DecomposeLUP</a> (const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Dim, Dim, Order, Layout, Packed &gt; &amp;m)</td></tr>
<tr class="memdesc:a7b93f1eecad5e31f23b17718c9371aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements LU decomposition with partial pivoting.  <a href="#a7b93f1eecad5e31f23b17718c9371aaf">More...</a><br /></td></tr>
<tr class="separator:a7b93f1eecad5e31f23b17718c9371aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aaa3f8329d7f3894a0ac6aad7b89924"><td class="memTemplParams" colspan="2">template&lt;class T , int Rows, int Columns, eMatrixOrder Order, eMatrixLayout Layout, bool Packed&gt; </td></tr>
<tr class="memitem:a4aaa3f8329d7f3894a0ac6aad7b89924"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a4aaa3f8329d7f3894a0ac6aad7b89924">DecomposeQR</a> (<a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order, Layout, Packed &gt; m)</td></tr>
<tr class="memdesc:a4aaa3f8329d7f3894a0ac6aad7b89924"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the QR decomposition of the matrix using Householder transforms.  <a href="#a4aaa3f8329d7f3894a0ac6aad7b89924">More...</a><br /></td></tr>
<tr class="separator:a4aaa3f8329d7f3894a0ac6aad7b89924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeada4b17cb1272d8b3090c600053970c"><td class="memTemplParams" colspan="2">template&lt;class T , int Rows, int Columns, eMatrixOrder Order, eMatrixLayout Layout, bool Packed&gt; </td></tr>
<tr class="memitem:aeada4b17cb1272d8b3090c600053970c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#aeada4b17cb1272d8b3090c600053970c">DecomposeSVD</a> (<a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order, Layout, Packed &gt; m)</td></tr>
<tr class="memdesc:aeada4b17cb1272d8b3090c600053970c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the thin SVD of the matrix.  <a href="#aeada4b17cb1272d8b3090c600053970c">More...</a><br /></td></tr>
<tr class="separator:aeada4b17cb1272d8b3090c600053970c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeb8316e14b5e73578e2a16913bb1ca5"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:afeb8316e14b5e73578e2a16913bb1ca5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#afeb8316e14b5e73578e2a16913bb1ca5">Intersect</a> (const T &amp;t, const U &amp;u)</td></tr>
<tr class="separator:afeb8316e14b5e73578e2a16913bb1ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ded50017eca8f308cbb7726449282d6"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed&gt; </td></tr>
<tr class="memitem:a1ded50017eca8f308cbb7726449282d6"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a1ded50017eca8f308cbb7726449282d6">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classmathter_1_1_vector.html">mathter::Vector</a>&lt; T, Dim, Packed &gt; &amp;v)</td></tr>
<tr class="memdesc:a1ded50017eca8f308cbb7726449282d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the vector like [1,2,3].  <a href="#a1ded50017eca8f308cbb7726449282d6">More...</a><br /></td></tr>
<tr class="separator:a1ded50017eca8f308cbb7726449282d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ca63078146085de2a6a3ec97ed7521"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed&gt; </td></tr>
<tr class="memitem:ac5ca63078146085de2a6a3ec97ed7521"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#ac5ca63078146085de2a6a3ec97ed7521">strtovec</a> (const char *str, const char **end)</td></tr>
<tr class="memdesc:ac5ca63078146085de2a6a3ec97ed7521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a vector from a string.  <a href="#ac5ca63078146085de2a6a3ec97ed7521">More...</a><br /></td></tr>
<tr class="separator:ac5ca63078146085de2a6a3ec97ed7521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeafceb87e09af648b2cb2837e0415f06"><td class="memTemplParams" colspan="2">template&lt;class VectorT &gt; </td></tr>
<tr class="memitem:aeafceb87e09af648b2cb2837e0415f06"><td class="memTemplItemLeft" align="right" valign="top">VectorT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#aeafceb87e09af648b2cb2837e0415f06">strtovec</a> (const char *str, const char **end)</td></tr>
<tr class="separator:aeafceb87e09af648b2cb2837e0415f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd74e9ce5289459089204ef8d24481ab"><td class="memTemplParams" colspan="2">template&lt;class T , int Rows, int Columns, eMatrixOrder Order, eMatrixLayout Layout, bool Packed&gt; </td></tr>
<tr class="memitem:afd74e9ce5289459089204ef8d24481ab"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#afd74e9ce5289459089204ef8d24481ab">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order, Layout, Packed &gt; &amp;mat)</td></tr>
<tr class="separator:afd74e9ce5289459089204ef8d24481ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a574048a2c54d675e0f8d724628c1ec79"><td class="memTemplParams" colspan="2">template&lt;class T , int Rows, int Columns, eMatrixOrder Order, eMatrixLayout Layout, bool Packed&gt; </td></tr>
<tr class="memitem:a574048a2c54d675e0f8d724628c1ec79"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order, Layout, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a574048a2c54d675e0f8d724628c1ec79">strtomat</a> (const char *str, const char **end)</td></tr>
<tr class="separator:a574048a2c54d675e0f8d724628c1ec79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8495cd6c02536d010b8cf749f430e43b"><td class="memTemplParams" colspan="2">template&lt;class MatrixT &gt; </td></tr>
<tr class="memitem:a8495cd6c02536d010b8cf749f430e43b"><td class="memTemplItemLeft" align="right" valign="top">MatrixT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a8495cd6c02536d010b8cf749f430e43b">strtomat</a> (const char *str, const char **end)</td></tr>
<tr class="separator:a8495cd6c02536d010b8cf749f430e43b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27a598d7c634aca7a712e667f0906df3"><td class="memTemplParams" colspan="2">template&lt;class T , bool Packed&gt; </td></tr>
<tr class="memitem:a27a598d7c634aca7a712e667f0906df3"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a27a598d7c634aca7a712e667f0906df3">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;q)</td></tr>
<tr class="separator:a27a598d7c634aca7a712e667f0906df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dfdb11fa3a6f03eb424182d7d098154"><td class="memTemplParams" colspan="2">template&lt;class T , class U , int Rows1, int Match, int Columns2, eMatrixOrder Order1, eMatrixOrder Order2, bool Packed, class V &gt; </td></tr>
<tr class="memitem:a8dfdb11fa3a6f03eb424182d7d098154"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a8dfdb11fa3a6f03eb424182d7d098154">operator*</a> (const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows1, Match, Order1, <a class="el" href="namespacemathter.html#aa43cfd54adea35fd8286213c5d198336a21541962976d7709c26e9cd8385bd648">eMatrixLayout::ROW_MAJOR</a>, Packed &gt; &amp;lhs, const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; U, Match, Columns2, Order2, <a class="el" href="namespacemathter.html#aa43cfd54adea35fd8286213c5d198336a21541962976d7709c26e9cd8385bd648">eMatrixLayout::ROW_MAJOR</a>, Packed &gt; &amp;rhs) -&gt; <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; V, Rows1, Columns2, Order1, <a class="el" href="namespacemathter.html#aa43cfd54adea35fd8286213c5d198336a21541962976d7709c26e9cd8385bd648">eMatrixLayout::ROW_MAJOR</a>, Packed &gt;</td></tr>
<tr class="separator:a8dfdb11fa3a6f03eb424182d7d098154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22d28fda3927adef04acb19d6c147d26"><td class="memTemplParams" colspan="2">template&lt;class T , class U , int Rows1, int Match, int Columns2, eMatrixOrder Order1, eMatrixOrder Order2, bool Packed, class V &gt; </td></tr>
<tr class="memitem:a22d28fda3927adef04acb19d6c147d26"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a22d28fda3927adef04acb19d6c147d26">operator*</a> (const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows1, Match, Order1, <a class="el" href="namespacemathter.html#aa43cfd54adea35fd8286213c5d198336a21541962976d7709c26e9cd8385bd648">eMatrixLayout::ROW_MAJOR</a>, Packed &gt; &amp;lhs, const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; U, Match, Columns2, Order2, <a class="el" href="namespacemathter.html#aa43cfd54adea35fd8286213c5d198336ada7520ed89bff27b02664af80951c6b0">eMatrixLayout::COLUMN_MAJOR</a>, Packed &gt; &amp;rhs) -&gt; <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; V, Rows1, Columns2, Order1, <a class="el" href="namespacemathter.html#aa43cfd54adea35fd8286213c5d198336a21541962976d7709c26e9cd8385bd648">eMatrixLayout::ROW_MAJOR</a>, Packed &gt;</td></tr>
<tr class="separator:a22d28fda3927adef04acb19d6c147d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a255d68cc40cc8e780f1264e43fdf9135"><td class="memTemplParams" colspan="2">template&lt;class T , class U , int Rows1, int Match, int Columns2, eMatrixOrder Order1, eMatrixOrder Order2, bool Packed, class V &gt; </td></tr>
<tr class="memitem:a255d68cc40cc8e780f1264e43fdf9135"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a255d68cc40cc8e780f1264e43fdf9135">operator*</a> (const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows1, Match, Order1, <a class="el" href="namespacemathter.html#aa43cfd54adea35fd8286213c5d198336ada7520ed89bff27b02664af80951c6b0">eMatrixLayout::COLUMN_MAJOR</a>, Packed &gt; &amp;lhs, const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; U, Match, Columns2, Order2, <a class="el" href="namespacemathter.html#aa43cfd54adea35fd8286213c5d198336ada7520ed89bff27b02664af80951c6b0">eMatrixLayout::COLUMN_MAJOR</a>, Packed &gt; &amp;rhs) -&gt; <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; V, Rows1, Columns2, Order1, <a class="el" href="namespacemathter.html#aa43cfd54adea35fd8286213c5d198336ada7520ed89bff27b02664af80951c6b0">eMatrixLayout::COLUMN_MAJOR</a>, Packed &gt;</td></tr>
<tr class="separator:a255d68cc40cc8e780f1264e43fdf9135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c5f9b26dea991066a12be89497fad1d"><td class="memTemplParams" colspan="2">template&lt;class T , class U , int Rows1, int Match, int Columns2, eMatrixOrder Order1, eMatrixOrder Order2, bool Packed, class V &gt; </td></tr>
<tr class="memitem:a7c5f9b26dea991066a12be89497fad1d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a7c5f9b26dea991066a12be89497fad1d">operator*</a> (const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows1, Match, Order1, <a class="el" href="namespacemathter.html#aa43cfd54adea35fd8286213c5d198336ada7520ed89bff27b02664af80951c6b0">eMatrixLayout::COLUMN_MAJOR</a>, Packed &gt; &amp;lhs, const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; U, Match, Columns2, Order2, <a class="el" href="namespacemathter.html#aa43cfd54adea35fd8286213c5d198336a21541962976d7709c26e9cd8385bd648">eMatrixLayout::ROW_MAJOR</a>, Packed &gt; &amp;rhs) -&gt; <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; V, Rows1, Columns2, Order1, <a class="el" href="namespacemathter.html#aa43cfd54adea35fd8286213c5d198336ada7520ed89bff27b02664af80951c6b0">eMatrixLayout::COLUMN_MAJOR</a>, Packed &gt;</td></tr>
<tr class="separator:a7c5f9b26dea991066a12be89497fad1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1463e21d3d76a468ad1930f7d8bf7412"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , int Rows1, int Match, int Columns2, eMatrixOrder Order1, eMatrixOrder Order2, eMatrixLayout Layout1, eMatrixLayout Layout2, bool PackedA&gt; </td></tr>
<tr class="memitem:a1463e21d3d76a468ad1930f7d8bf7412"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a1463e21d3d76a468ad1930f7d8bf7412">operator*</a> (const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T1, Rows1, Match, Order1, Layout1, PackedA &gt; &amp;lhs, const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T2, Match, Columns2, Order2, Layout2, PackedA &gt; &amp;rhs) -&gt; <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; <a class="el" href="namespacemathter_1_1traits.html#a859c47fdf245eb5d7313ea9cf4f1c071">traits::MatMulElemT</a>&lt; T1, T2 &gt;, Rows1, Columns2, Order1, Layout1, PackedA &gt;</td></tr>
<tr class="separator:a1463e21d3d76a468ad1930f7d8bf7412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8259997b1f5c5c79f98f31beba486307"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , int Dim, eMatrixOrder Order1, eMatrixOrder Order2, eMatrixLayout Layout1, eMatrixLayout Layout2, bool Packed&gt; </td></tr>
<tr class="memitem:a8259997b1f5c5c79f98f31beba486307"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T1, Dim, Dim, Order1, Layout1, Packed &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a8259997b1f5c5c79f98f31beba486307">operator*=</a> (<a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T1, Dim, Dim, Order1, Layout1, Packed &gt; &amp;lhs, const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T2, Dim, Dim, Order2, Layout2, Packed &gt; &amp;rhs)</td></tr>
<tr class="separator:a8259997b1f5c5c79f98f31beba486307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a89f7b9fd22087f33c47d59e96ab9ce"><td class="memTemplParams" colspan="2">template&lt;class T , class U , int Rows, int Columns, eMatrixOrder Order1, eMatrixOrder Order2, eMatrixLayout SameLayout, bool Packed, class V  = decltype(T() + U())&gt; </td></tr>
<tr class="memitem:a8a89f7b9fd22087f33c47d59e96ab9ce"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; U, Rows, Columns, Order1, SameLayout, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a8a89f7b9fd22087f33c47d59e96ab9ce">operator+</a> (const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order1, SameLayout, Packed &gt; &amp;lhs, const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; U, Rows, Columns, Order2, SameLayout, Packed &gt; &amp;rhs)</td></tr>
<tr class="separator:a8a89f7b9fd22087f33c47d59e96ab9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4083f119a7550afa4e3237bb50c384f6"><td class="memTemplParams" colspan="2">template&lt;class T , class U , int Rows, int Columns, eMatrixOrder Order1, eMatrixOrder Order2, eMatrixLayout SameLayout, bool Packed, class V  = decltype(T() - U())&gt; </td></tr>
<tr class="memitem:a4083f119a7550afa4e3237bb50c384f6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; U, Rows, Columns, Order1, SameLayout, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a4083f119a7550afa4e3237bb50c384f6">operator-</a> (const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order1, SameLayout, Packed &gt; &amp;lhs, const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; U, Rows, Columns, Order2, SameLayout, Packed &gt; &amp;rhs)</td></tr>
<tr class="separator:a4083f119a7550afa4e3237bb50c384f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e02f95e30162f06b260143a06576b93"><td class="memTemplParams" colspan="2">template&lt;class T , class U , int Rows, int Columns, eMatrixOrder Order1, eMatrixOrder Order2, eMatrixLayout Layout1, eMatrixLayout Layout2, bool Packed, class V , class  = typename std::enable_if&lt;Layout1 != Layout2&gt;::type&gt; </td></tr>
<tr class="memitem:a1e02f95e30162f06b260143a06576b93"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; U, Rows, Columns, Order1, Layout1, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a1e02f95e30162f06b260143a06576b93">operator+</a> (const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order1, Layout1, Packed &gt; &amp;lhs, const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; U, Rows, Columns, Order2, Layout2, Packed &gt; &amp;rhs)</td></tr>
<tr class="separator:a1e02f95e30162f06b260143a06576b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b5d81c9c2433e8bec4d9b370400119"><td class="memTemplParams" colspan="2">template&lt;class T , class U , int Rows, int Columns, eMatrixOrder Order1, eMatrixOrder Order2, eMatrixLayout Layout1, eMatrixLayout Layout2, bool Packed, class V , class  = typename std::enable_if&lt;Layout1 != Layout2&gt;::type&gt; </td></tr>
<tr class="memitem:ae5b5d81c9c2433e8bec4d9b370400119"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; U, Rows, Columns, Order1, Layout1, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#ae5b5d81c9c2433e8bec4d9b370400119">operator-</a> (const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order1, Layout1, Packed &gt; &amp;lhs, const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; U, Rows, Columns, Order2, Layout2, Packed &gt; &amp;rhs)</td></tr>
<tr class="separator:ae5b5d81c9c2433e8bec4d9b370400119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1545a4d34838e071ce79d4e003f79dcb"><td class="memTemplParams" colspan="2">template&lt;class T , class U , int Rows, int Columns, eMatrixOrder Order1, eMatrixOrder Order2, eMatrixLayout Layout1, eMatrixLayout Layout2, bool Packed, class V &gt; </td></tr>
<tr class="memitem:a1545a4d34838e071ce79d4e003f79dcb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; U, Rows, Columns, Order1, Layout1, Packed &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a1545a4d34838e071ce79d4e003f79dcb">operator+=</a> (<a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order1, Layout1, Packed &gt; &amp;lhs, const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; U, Rows, Columns, Order2, Layout2, Packed &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a1545a4d34838e071ce79d4e003f79dcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs matrix addition and stores result in this.  <a href="#a1545a4d34838e071ce79d4e003f79dcb">More...</a><br /></td></tr>
<tr class="separator:a1545a4d34838e071ce79d4e003f79dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02467cad892a559b4183c6a9f61fa5f5"><td class="memTemplParams" colspan="2">template&lt;class T , class U , int Rows, int Columns, eMatrixOrder Order1, eMatrixOrder Order2, eMatrixLayout Layout1, eMatrixLayout Layout2, bool Packed, class V &gt; </td></tr>
<tr class="memitem:a02467cad892a559b4183c6a9f61fa5f5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; U, Rows, Columns, Order1, Layout1, Packed &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a02467cad892a559b4183c6a9f61fa5f5">operator-=</a> (<a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order1, Layout1, Packed &gt; &amp;lhs, const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; U, Rows, Columns, Order2, Layout2, Packed &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a02467cad892a559b4183c6a9f61fa5f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs matrix subtraction and stores result in this.  <a href="#a02467cad892a559b4183c6a9f61fa5f5">More...</a><br /></td></tr>
<tr class="separator:a02467cad892a559b4183c6a9f61fa5f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a455d71dce14efaeb8719c1892c703"><td class="memTemplParams" colspan="2">template&lt;class T , int Rows, int Columns, eMatrixOrder Order, eMatrixLayout Layout, bool Packed&gt; </td></tr>
<tr class="memitem:af8a455d71dce14efaeb8719c1892c703"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order, Layout, Packed &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#af8a455d71dce14efaeb8719c1892c703">operator*=</a> (<a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order, Layout, Packed &gt; &amp;mat, T s)</td></tr>
<tr class="memdesc:af8a455d71dce14efaeb8719c1892c703"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies all elements of the matrix by scalar.  <a href="#af8a455d71dce14efaeb8719c1892c703">More...</a><br /></td></tr>
<tr class="separator:af8a455d71dce14efaeb8719c1892c703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15873b3ca92b2656885879c133865756"><td class="memTemplParams" colspan="2">template&lt;class T , int Rows, int Columns, eMatrixOrder Order, eMatrixLayout Layout, bool Packed&gt; </td></tr>
<tr class="memitem:a15873b3ca92b2656885879c133865756"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order, Layout, Packed &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a15873b3ca92b2656885879c133865756">operator/=</a> (<a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order, Layout, Packed &gt; &amp;mat, T s)</td></tr>
<tr class="memdesc:a15873b3ca92b2656885879c133865756"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides all elements of the matrix by scalar.  <a href="#a15873b3ca92b2656885879c133865756">More...</a><br /></td></tr>
<tr class="separator:a15873b3ca92b2656885879c133865756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab01b8d3364ce00bee75bf988ecc50569"><td class="memTemplParams" colspan="2">template&lt;class T , int Rows, int Columns, eMatrixOrder Order, eMatrixLayout Layout, bool Packed&gt; </td></tr>
<tr class="memitem:ab01b8d3364ce00bee75bf988ecc50569"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order, Layout, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#ab01b8d3364ce00bee75bf988ecc50569">operator*</a> (T s, const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order, Layout, Packed &gt; &amp;mat)</td></tr>
<tr class="separator:ab01b8d3364ce00bee75bf988ecc50569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb99d0f900a2acdcdfd5f0579b2af80"><td class="memTemplParams" colspan="2">template&lt;class T , int Rows, int Columns, eMatrixOrder Order, eMatrixLayout Layout, bool Packed&gt; </td></tr>
<tr class="memitem:a1bb99d0f900a2acdcdfd5f0579b2af80"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order, Layout, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a1bb99d0f900a2acdcdfd5f0579b2af80">operator/</a> (T s, const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order, Layout, Packed &gt; &amp;mat)</td></tr>
<tr class="separator:a1bb99d0f900a2acdcdfd5f0579b2af80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ebf763d2b38787b8cd25ff1ca51fae3"><td class="memTemplParams" colspan="2">template&lt;class T , int Rows, int Columns, eMatrixOrder Order, eMatrixLayout Layout, bool Packed&gt; </td></tr>
<tr class="memitem:a9ebf763d2b38787b8cd25ff1ca51fae3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order, Layout, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a9ebf763d2b38787b8cd25ff1ca51fae3">operator*</a> (const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order, Layout, Packed &gt; &amp;mat, T s)</td></tr>
<tr class="separator:a9ebf763d2b38787b8cd25ff1ca51fae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c3eecacec100b8f050d67a3ee71fb9"><td class="memTemplParams" colspan="2">template&lt;class T , int Rows, int Columns, eMatrixOrder Order, eMatrixLayout Layout, bool Packed&gt; </td></tr>
<tr class="memitem:a43c3eecacec100b8f050d67a3ee71fb9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order, Layout, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a43c3eecacec100b8f050d67a3ee71fb9">operator/</a> (const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order, Layout, Packed &gt; &amp;mat, T s)</td></tr>
<tr class="separator:a43c3eecacec100b8f050d67a3ee71fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b5091b070bbebe24fd568ab6836e712"><td class="memTemplParams" colspan="2">template&lt;class T , class T2 , int Rows, int Columns, eMatrixOrder Order, eMatrixOrder Order2, eMatrixLayout Layout, bool Packed&gt; </td></tr>
<tr class="memitem:a2b5091b070bbebe24fd568ab6836e712"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a2b5091b070bbebe24fd568ab6836e712">MulElementwise</a> (const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order, Layout, Packed &gt; &amp;lhs, const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T2, Rows, Columns, Order2, Layout, Packed &gt; &amp;rhs)</td></tr>
<tr class="separator:a2b5091b070bbebe24fd568ab6836e712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a704247409f83a99c1ed738cb3742c0bb"><td class="memTemplParams" colspan="2">template&lt;class T , class T2 , int Rows, int Columns, eMatrixOrder Order, eMatrixOrder Order2, eMatrixLayout Layout, bool Packed&gt; </td></tr>
<tr class="memitem:a704247409f83a99c1ed738cb3742c0bb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a704247409f83a99c1ed738cb3742c0bb">MulElementwise</a> (const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order, Layout, Packed &gt; &amp;lhs, const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T2, Rows, Columns, Order2, <a class="el" href="classmathter_1_1traits_1_1_opposite_layout.html">traits::OppositeLayout</a>&lt; Layout &gt;::value, Packed &gt; &amp;rhs)</td></tr>
<tr class="separator:a704247409f83a99c1ed738cb3742c0bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c9775a2294478c2ed45d42ac3c977ba"><td class="memTemplParams" colspan="2">template&lt;class T , class T2 , int Rows, int Columns, eMatrixOrder Order, eMatrixOrder Order2, eMatrixLayout Layout, bool Packed&gt; </td></tr>
<tr class="memitem:a1c9775a2294478c2ed45d42ac3c977ba"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a1c9775a2294478c2ed45d42ac3c977ba">DivElementwise</a> (const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order, Layout, Packed &gt; &amp;lhs, const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T2, Rows, Columns, Order2, Layout, Packed &gt; &amp;rhs)</td></tr>
<tr class="separator:a1c9775a2294478c2ed45d42ac3c977ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac37f97dbaaebc376820be97e3cdd77bc"><td class="memTemplParams" colspan="2">template&lt;class T , class T2 , int Rows, int Columns, eMatrixOrder Order, eMatrixOrder Order2, eMatrixLayout Layout, bool Packed&gt; </td></tr>
<tr class="memitem:ac37f97dbaaebc376820be97e3cdd77bc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#ac37f97dbaaebc376820be97e3cdd77bc">DivElementwise</a> (const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order, Layout, Packed &gt; &amp;lhs, const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T2, Rows, Columns, Order2, <a class="el" href="classmathter_1_1traits_1_1_opposite_layout.html">traits::OppositeLayout</a>&lt; Layout &gt;::value, Packed &gt; &amp;rhs)</td></tr>
<tr class="separator:ac37f97dbaaebc376820be97e3cdd77bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac50982566194d1bbfbebf3b5af798552"><td class="memTemplParams" colspan="2">template&lt;class U , class T , int Rows, int Columns, eMatrixOrder Order, eMatrixLayout Layout, bool Packed&gt; </td></tr>
<tr class="memitem:ac50982566194d1bbfbebf3b5af798552"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order, Layout, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#ac50982566194d1bbfbebf3b5af798552">operator+</a> (const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order, Layout, Packed &gt; &amp;mat)</td></tr>
<tr class="separator:ac50982566194d1bbfbebf3b5af798552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5b600117256aeda7aaf1894fc09b99"><td class="memTemplParams" colspan="2">template&lt;class U , class T , int Rows, int Columns, eMatrixOrder Order, eMatrixLayout Layout, bool Packed&gt; </td></tr>
<tr class="memitem:ade5b600117256aeda7aaf1894fc09b99"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order, Layout, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#ade5b600117256aeda7aaf1894fc09b99">operator-</a> (const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order, Layout, Packed &gt; &amp;mat)</td></tr>
<tr class="separator:ade5b600117256aeda7aaf1894fc09b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a46fa6467ff9454b11422445a01f3d"><td class="memTemplParams" colspan="2">template&lt;int Rows, int Columns, class T1 , class T2 , eMatrixOrder Order1, eMatrixOrder Order2, eMatrixLayout Layout1, eMatrixLayout Layout2, bool Packed1, bool Packed2&gt; </td></tr>
<tr class="memitem:ad1a46fa6467ff9454b11422445a01f3d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#ad1a46fa6467ff9454b11422445a01f3d">operator==</a> (const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T1, Rows, Columns, Order1, Layout1, Packed1 &gt; &amp;lhs, const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T2, Rows, Columns, Order2, Layout2, Packed2 &gt; &amp;rhs)</td></tr>
<tr class="separator:ad1a46fa6467ff9454b11422445a01f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cfc7bee93e028f1e39589b4b634b075"><td class="memTemplParams" colspan="2">template&lt;int Rows, int Columns, class T1 , class T2 , eMatrixOrder Order1, eMatrixOrder Order2, eMatrixLayout Layout1, eMatrixLayout Layout2, bool Packed1, bool Packed2&gt; </td></tr>
<tr class="memitem:a1cfc7bee93e028f1e39589b4b634b075"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a1cfc7bee93e028f1e39589b4b634b075">operator!=</a> (const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T1, Rows, Columns, Order1, Layout1, Packed1 &gt; &amp;lhs, const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T2, Rows, Columns, Order2, Layout2, Packed2 &gt; &amp;rhs)</td></tr>
<tr class="separator:a1cfc7bee93e028f1e39589b4b634b075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a996e71fba0ff213b062c218adc51fac2"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, eMatrixOrder Order, eMatrixLayout Layout, bool Packed&gt; </td></tr>
<tr class="memitem:a996e71fba0ff213b062c218adc51fac2"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a996e71fba0ff213b062c218adc51fac2">Trace</a> (const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Dim, Dim, Order, Layout, Packed &gt; &amp;m)</td></tr>
<tr class="memdesc:a996e71fba0ff213b062c218adc51fac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the trace (sum of diagonal elements) of the matrix.  <a href="#a996e71fba0ff213b062c218adc51fac2">More...</a><br /></td></tr>
<tr class="separator:a996e71fba0ff213b062c218adc51fac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade013562d383964232eaa66339cf91be"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, eMatrixOrder Order, eMatrixLayout Layout, bool Packed&gt; </td></tr>
<tr class="memitem:ade013562d383964232eaa66339cf91be"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#ade013562d383964232eaa66339cf91be">Determinant</a> (const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Dim, Dim, Order, Layout, Packed &gt; &amp;m)</td></tr>
<tr class="memdesc:ade013562d383964232eaa66339cf91be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the determinant of the matrix.  <a href="#ade013562d383964232eaa66339cf91be">More...</a><br /></td></tr>
<tr class="separator:ade013562d383964232eaa66339cf91be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8539b36ef4095668525d638c0ca74e4b"><td class="memTemplParams" colspan="2">template&lt;class T , int Rows, int Columns, eMatrixOrder Order, eMatrixLayout Layout, bool Packed&gt; </td></tr>
<tr class="memitem:a8539b36ef4095668525d638c0ca74e4b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Columns, Rows, Order, Layout, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a8539b36ef4095668525d638c0ca74e4b">Transpose</a> (const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order, Layout, Packed &gt; &amp;m)</td></tr>
<tr class="memdesc:a8539b36ef4095668525d638c0ca74e4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposes the matrix in-place.  <a href="#a8539b36ef4095668525d638c0ca74e4b">More...</a><br /></td></tr>
<tr class="separator:a8539b36ef4095668525d638c0ca74e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac58867fce293c7e6a24e8383802e8c7d"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, eMatrixOrder Order, eMatrixLayout Layout, bool Packed&gt; </td></tr>
<tr class="memitem:ac58867fce293c7e6a24e8383802e8c7d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Dim, Dim, Order, Layout, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#ac58867fce293c7e6a24e8383802e8c7d">Inverse</a> (const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Dim, Dim, Order, Layout, Packed &gt; &amp;m)</td></tr>
<tr class="memdesc:ac58867fce293c7e6a24e8383802e8c7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the inverse of the matrix.  <a href="#ac58867fce293c7e6a24e8383802e8c7d">More...</a><br /></td></tr>
<tr class="separator:ac58867fce293c7e6a24e8383802e8c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f5608905538ebefa7d5fafdc20826a0"><td class="memTemplParams" colspan="2">template&lt;class T , int Rows, int Columns, eMatrixOrder Order, eMatrixLayout Layout, bool Packed&gt; </td></tr>
<tr class="memitem:a0f5608905538ebefa7d5fafdc20826a0"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a0f5608905538ebefa7d5fafdc20826a0">NormSquared</a> (const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order, Layout, Packed &gt; &amp;m)</td></tr>
<tr class="memdesc:a0f5608905538ebefa7d5fafdc20826a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the square of the Frobenius norm of the matrix.  <a href="#a0f5608905538ebefa7d5fafdc20826a0">More...</a><br /></td></tr>
<tr class="separator:a0f5608905538ebefa7d5fafdc20826a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a139e1f15e50dcc982c17906832e7cd6b"><td class="memTemplParams" colspan="2">template&lt;class T , int Rows, int Columns, eMatrixOrder Order, eMatrixLayout Layout, bool Packed&gt; </td></tr>
<tr class="memitem:a139e1f15e50dcc982c17906832e7cd6b"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a139e1f15e50dcc982c17906832e7cd6b">Norm</a> (const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order, Layout, Packed &gt; &amp;m)</td></tr>
<tr class="memdesc:a139e1f15e50dcc982c17906832e7cd6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the Frobenius norm of the matrix.  <a href="#a139e1f15e50dcc982c17906832e7cd6b">More...</a><br /></td></tr>
<tr class="separator:a139e1f15e50dcc982c17906832e7cd6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9cf6b563c14f18ff2c5f6c941630374"><td class="memTemplParams" colspan="2">template&lt;class Vt , class Mt , int Vd, int Mcol, eMatrixOrder Morder, bool Packed, class Rt &gt; </td></tr>
<tr class="memitem:af9cf6b563c14f18ff2c5f6c941630374"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; Rt, Mcol, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#af9cf6b563c14f18ff2c5f6c941630374">operator*</a> (const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; Vt, Vd, Packed &gt; &amp;vec, const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; Mt, Vd, Mcol, Morder, <a class="el" href="namespacemathter.html#aa43cfd54adea35fd8286213c5d198336a21541962976d7709c26e9cd8385bd648">eMatrixLayout::ROW_MAJOR</a>, Packed &gt; &amp;mat)</td></tr>
<tr class="separator:af9cf6b563c14f18ff2c5f6c941630374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c1d88a03fd648114ca44cf865286792"><td class="memTemplParams" colspan="2">template&lt;class Vt , class Mt , int Vd, int Mcol, eMatrixOrder Morder, bool Packed, class Rt &gt; </td></tr>
<tr class="memitem:a4c1d88a03fd648114ca44cf865286792"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; Rt, Mcol, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a4c1d88a03fd648114ca44cf865286792">operator*</a> (const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; Vt, Vd, Packed &gt; &amp;vec, const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; Mt, Vd, Mcol, Morder, <a class="el" href="namespacemathter.html#aa43cfd54adea35fd8286213c5d198336ada7520ed89bff27b02664af80951c6b0">eMatrixLayout::COLUMN_MAJOR</a>, Packed &gt; &amp;mat)</td></tr>
<tr class="separator:a4c1d88a03fd648114ca44cf865286792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7029f205897464ccef7b3d9f2809c518"><td class="memTemplParams" colspan="2">template&lt;class Vt , class Mt , int Vd, int Mcol, eMatrixOrder Morder, eMatrixLayout Mlayout, bool Packed&gt; </td></tr>
<tr class="memitem:a7029f205897464ccef7b3d9f2809c518"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; <a class="el" href="namespacemathter_1_1traits.html#a859c47fdf245eb5d7313ea9cf4f1c071">traits::MatMulElemT</a>&lt; Vt, Mt &gt;, Mcol, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a7029f205897464ccef7b3d9f2809c518">operator*</a> (const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; Vt, Vd, Packed &gt; &amp;vec, const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; Mt, Vd, Mcol, Morder, Mlayout, Packed &gt; &amp;mat)</td></tr>
<tr class="separator:a7029f205897464ccef7b3d9f2809c518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b2b7dcd7569a845fac513bd24f05900"><td class="memTemplParams" colspan="2">template&lt;class Vt , class Mt , int Vd, eMatrixLayout Mlayout, eMatrixOrder Morder, bool Packed, class Rt  = traits::MatMulElemT&lt;Vt, Mt&gt;&gt; </td></tr>
<tr class="memitem:a2b2b7dcd7569a845fac513bd24f05900"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; Rt, Vd, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a2b2b7dcd7569a845fac513bd24f05900">operator*</a> (const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; Vt, Vd, Packed &gt; &amp;vec, const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; Mt, Vd+1, Vd, Morder, Mlayout, Packed &gt; &amp;mat)</td></tr>
<tr class="separator:a2b2b7dcd7569a845fac513bd24f05900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad01624f8752fb86e2f336e88d1b32323"><td class="memTemplParams" colspan="2">template&lt;class Vt , class Mt , int Vd, eMatrixLayout Mlayout, eMatrixOrder Morder, bool Packed, class Rt  = traits::MatMulElemT&lt;Vt, Mt&gt;&gt; </td></tr>
<tr class="memitem:ad01624f8752fb86e2f336e88d1b32323"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; Rt, Vd, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#ad01624f8752fb86e2f336e88d1b32323">operator*</a> (const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; Vt, Vd, Packed &gt; &amp;vec, const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; Mt, Vd+1, Vd+1, Morder, Mlayout, Packed &gt; &amp;mat)</td></tr>
<tr class="separator:ad01624f8752fb86e2f336e88d1b32323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f18e5fba716e84d59dc99c2431dee70"><td class="memTemplParams" colspan="2">template&lt;class Vt , class Mt , int Vd, int Mrow, eMatrixOrder Morder, bool Packed, class Rt &gt; </td></tr>
<tr class="memitem:a2f18e5fba716e84d59dc99c2431dee70"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; Rt, Mrow, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a2f18e5fba716e84d59dc99c2431dee70">operator*</a> (const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; Mt, Mrow, Vd, Morder, <a class="el" href="namespacemathter.html#aa43cfd54adea35fd8286213c5d198336a21541962976d7709c26e9cd8385bd648">eMatrixLayout::ROW_MAJOR</a>, Packed &gt; &amp;mat, const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; Vt, Vd, Packed &gt; &amp;vec)</td></tr>
<tr class="separator:a2f18e5fba716e84d59dc99c2431dee70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cc58f6b6189a97325c37730f0928159"><td class="memTemplParams" colspan="2">template&lt;class Vt , class Mt , int Vd, int Mrow, eMatrixOrder Morder, bool Packed, class Rt &gt; </td></tr>
<tr class="memitem:a1cc58f6b6189a97325c37730f0928159"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; Rt, Mrow, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a1cc58f6b6189a97325c37730f0928159">operator*</a> (const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; Mt, Mrow, Vd, Morder, <a class="el" href="namespacemathter.html#aa43cfd54adea35fd8286213c5d198336ada7520ed89bff27b02664af80951c6b0">eMatrixLayout::COLUMN_MAJOR</a>, Packed &gt; &amp;mat, const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; Vt, Vd, Packed &gt; &amp;vec)</td></tr>
<tr class="separator:a1cc58f6b6189a97325c37730f0928159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d0c4c785dd28bba5c0ce69b4f072e3c"><td class="memTemplParams" colspan="2">template&lt;class Vt , class Mt , int Vd, int Mrow, eMatrixOrder Morder, eMatrixLayout Mlayout, bool Packed&gt; </td></tr>
<tr class="memitem:a9d0c4c785dd28bba5c0ce69b4f072e3c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; <a class="el" href="namespacemathter_1_1traits.html#a859c47fdf245eb5d7313ea9cf4f1c071">traits::MatMulElemT</a>&lt; Vt, Mt &gt;, Mrow, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a9d0c4c785dd28bba5c0ce69b4f072e3c">operator*</a> (const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; Mt, Mrow, Vd, Morder, Mlayout, Packed &gt; &amp;mat, const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; Vt, Vd, Packed &gt; &amp;vec)</td></tr>
<tr class="separator:a9d0c4c785dd28bba5c0ce69b4f072e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7df3d1a68f83e4308b710bb3aee7a8ff"><td class="memTemplParams" colspan="2">template&lt;class Vt , class Mt , int Vd, eMatrixLayout Mlayout, eMatrixOrder Morder, bool Packed, class Rt  = traits::MatMulElemT&lt;Vt, Mt&gt;&gt; </td></tr>
<tr class="memitem:a7df3d1a68f83e4308b710bb3aee7a8ff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; Rt, Vd, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a7df3d1a68f83e4308b710bb3aee7a8ff">operator*</a> (const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; Mt, Vd, Vd+1, Morder, Mlayout, Packed &gt; &amp;mat, const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; Vt, Vd, Packed &gt; &amp;vec)</td></tr>
<tr class="separator:a7df3d1a68f83e4308b710bb3aee7a8ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a7a8f5346901d6179e16b0029704ea"><td class="memTemplParams" colspan="2">template&lt;class Vt , class Mt , int Vd, eMatrixLayout Mlayout, eMatrixOrder Morder, bool Packed, class Rt  = traits::MatMulElemT&lt;Vt, Mt&gt;&gt; </td></tr>
<tr class="memitem:a78a7a8f5346901d6179e16b0029704ea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; Rt, Vd, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a78a7a8f5346901d6179e16b0029704ea">operator*</a> (const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; Mt, Vd+1, Vd+1, Morder, Mlayout, Packed &gt; &amp;mat, const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; Vt, Vd, Packed &gt; &amp;vec)</td></tr>
<tr class="separator:a78a7a8f5346901d6179e16b0029704ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3ced1b5e3c395ebdcdbf86ca2d2f20a"><td class="memTemplParams" colspan="2">template&lt;class Vt , class Mt , int Vd, eMatrixOrder Morder, eMatrixLayout Layout, bool Packed&gt; </td></tr>
<tr class="memitem:ac3ced1b5e3c395ebdcdbf86ca2d2f20a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; Vt, Vd, Packed &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#ac3ced1b5e3c395ebdcdbf86ca2d2f20a">operator*=</a> (<a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; Vt, Vd, Packed &gt; &amp;vec, const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; Mt, Vd, Vd, Morder, Layout, Packed &gt; &amp;mat)</td></tr>
<tr class="separator:ac3ced1b5e3c395ebdcdbf86ca2d2f20a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b2787f569da1a60d47f27163e78d7c7"><td class="memTemplParams" colspan="2">template&lt;class T , bool Packed&gt; </td></tr>
<tr class="memitem:a2b2787f569da1a60d47f27163e78d7c7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a2b2787f569da1a60d47f27163e78d7c7">operator+=</a> (<a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;lhs, const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;rhs)</td></tr>
<tr class="separator:a2b2787f569da1a60d47f27163e78d7c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13904d0192606fb6fb982dcf78d474fc"><td class="memTemplParams" colspan="2">template&lt;class T , bool Packed&gt; </td></tr>
<tr class="memitem:a13904d0192606fb6fb982dcf78d474fc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a13904d0192606fb6fb982dcf78d474fc">operator-=</a> (<a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;lhs, const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;rhs)</td></tr>
<tr class="separator:a13904d0192606fb6fb982dcf78d474fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac88918d571d04cac40bfd8b335bb34"><td class="memTemplParams" colspan="2">template&lt;class T , bool Packed&gt; </td></tr>
<tr class="memitem:a6ac88918d571d04cac40bfd8b335bb34"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a6ac88918d571d04cac40bfd8b335bb34">operator*=</a> (<a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;lhs, const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;rhs)</td></tr>
<tr class="separator:a6ac88918d571d04cac40bfd8b335bb34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ba8f46b00061ea189520eb21da66a1"><td class="memTemplParams" colspan="2">template&lt;class T , bool Packed&gt; </td></tr>
<tr class="memitem:a91ba8f46b00061ea189520eb21da66a1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a91ba8f46b00061ea189520eb21da66a1">operator*=</a> (<a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;lhs, T s)</td></tr>
<tr class="separator:a91ba8f46b00061ea189520eb21da66a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e65a21406262127da06a0ad333e2a0"><td class="memTemplParams" colspan="2">template&lt;class T , bool Packed&gt; </td></tr>
<tr class="memitem:ac0e65a21406262127da06a0ad333e2a0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#ac0e65a21406262127da06a0ad333e2a0">operator/=</a> (<a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;lhs, T s)</td></tr>
<tr class="separator:ac0e65a21406262127da06a0ad333e2a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a140882fe6701f061e3cdb616ee8820b1"><td class="memTemplParams" colspan="2">template&lt;class T , bool Packed&gt; </td></tr>
<tr class="memitem:a140882fe6701f061e3cdb616ee8820b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a140882fe6701f061e3cdb616ee8820b1">operator+</a> (const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;lhs, const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;rhs)</td></tr>
<tr class="separator:a140882fe6701f061e3cdb616ee8820b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec2084d2097d2cd28c640624cae053b8"><td class="memTemplParams" colspan="2">template&lt;class T , bool Packed&gt; </td></tr>
<tr class="memitem:aec2084d2097d2cd28c640624cae053b8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#aec2084d2097d2cd28c640624cae053b8">operator-</a> (const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;lhs, const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;rhs)</td></tr>
<tr class="separator:aec2084d2097d2cd28c640624cae053b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b6232ccc675fdd581afc6240663cfa7"><td class="memTemplParams" colspan="2">template&lt;class T , bool Packed&gt; </td></tr>
<tr class="memitem:a9b6232ccc675fdd581afc6240663cfa7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a9b6232ccc675fdd581afc6240663cfa7">operator*</a> (const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;lhs, const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;rhs)</td></tr>
<tr class="separator:a9b6232ccc675fdd581afc6240663cfa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a149b08eafef328af95e3da82fd9c6f"><td class="memTemplParams" colspan="2">template&lt;class T , bool Packed&gt; </td></tr>
<tr class="memitem:a3a149b08eafef328af95e3da82fd9c6f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a3a149b08eafef328af95e3da82fd9c6f">operator*</a> (const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;lhs, T s)</td></tr>
<tr class="separator:a3a149b08eafef328af95e3da82fd9c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1504e2c2afc7d8f2fe85fcbe292cb578"><td class="memTemplParams" colspan="2">template&lt;class T , bool Packed&gt; </td></tr>
<tr class="memitem:a1504e2c2afc7d8f2fe85fcbe292cb578"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a1504e2c2afc7d8f2fe85fcbe292cb578">operator/</a> (const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;lhs, T s)</td></tr>
<tr class="separator:a1504e2c2afc7d8f2fe85fcbe292cb578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7186d91a61ea4f0170144b1cebe35d21"><td class="memTemplParams" colspan="2">template&lt;class T , bool Packed&gt; </td></tr>
<tr class="memitem:a7186d91a61ea4f0170144b1cebe35d21"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a7186d91a61ea4f0170144b1cebe35d21">operator+</a> (const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;arg)</td></tr>
<tr class="separator:a7186d91a61ea4f0170144b1cebe35d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9e642a408702d0d148cf434ce8f5ed4"><td class="memTemplParams" colspan="2">template&lt;class T , bool Packed&gt; </td></tr>
<tr class="memitem:ab9e642a408702d0d148cf434ce8f5ed4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#ab9e642a408702d0d148cf434ce8f5ed4">operator-</a> (const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;arg)</td></tr>
<tr class="separator:ab9e642a408702d0d148cf434ce8f5ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1afc380149f6caac62a26d64b12273b"><td class="memTemplParams" colspan="2">template&lt;class T , bool Packed, class U , class  = typename std::enable_if&lt;!std::is_same&lt;U, Quaternion&lt;T, Packed&gt;&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:aa1afc380149f6caac62a26d64b12273b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#aa1afc380149f6caac62a26d64b12273b">operator*</a> (U s, const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aa1afc380149f6caac62a26d64b12273b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies all coefficients of the quaternion by <em>s</em> .  <a href="#aa1afc380149f6caac62a26d64b12273b">More...</a><br /></td></tr>
<tr class="separator:aa1afc380149f6caac62a26d64b12273b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39081aa028277f443efd1f77f0311bd8"><td class="memTemplParams" colspan="2">template&lt;class T , bool Packed, class U , class  = typename std::enable_if&lt;!std::is_same&lt;U, Quaternion&lt;T, Packed&gt;&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a39081aa028277f443efd1f77f0311bd8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a39081aa028277f443efd1f77f0311bd8">operator/</a> (U s, const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a39081aa028277f443efd1f77f0311bd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides all coefficients of the quaternion by <em>s</em> .  <a href="#a39081aa028277f443efd1f77f0311bd8">More...</a><br /></td></tr>
<tr class="separator:a39081aa028277f443efd1f77f0311bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff4214a57ff4ef0a23997254b08588cb"><td class="memTemplParams" colspan="2">template&lt;class T , bool Packed, class U , class  = typename std::enable_if&lt;!traits::IsQuaternion&lt;U&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:aff4214a57ff4ef0a23997254b08588cb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#aff4214a57ff4ef0a23997254b08588cb">operator+</a> (const U &amp;lhs, const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aff4214a57ff4ef0a23997254b08588cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a real to the real part of the quaternion.  <a href="#aff4214a57ff4ef0a23997254b08588cb">More...</a><br /></td></tr>
<tr class="separator:aff4214a57ff4ef0a23997254b08588cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a986fe6c4bffc6dcf1145a4ead56b0a7b"><td class="memTemplParams" colspan="2">template&lt;class T , bool Packed&gt; </td></tr>
<tr class="memitem:a986fe6c4bffc6dcf1145a4ead56b0a7b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a986fe6c4bffc6dcf1145a4ead56b0a7b">operator==</a> (const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;lhs, const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a986fe6c4bffc6dcf1145a4ead56b0a7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check exact equality of coefficients.  <a href="#a986fe6c4bffc6dcf1145a4ead56b0a7b">More...</a><br /></td></tr>
<tr class="separator:a986fe6c4bffc6dcf1145a4ead56b0a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8af196535873baeabcba0467a55ffc8e"><td class="memTemplParams" colspan="2">template&lt;class T , bool Packed&gt; </td></tr>
<tr class="memitem:a8af196535873baeabcba0467a55ffc8e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a8af196535873baeabcba0467a55ffc8e">operator!=</a> (const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;lhs, const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a8af196535873baeabcba0467a55ffc8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check exact unequality of coefficients.  <a href="#a8af196535873baeabcba0467a55ffc8e">More...</a><br /></td></tr>
<tr class="separator:a8af196535873baeabcba0467a55ffc8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae676fff5afb56c796e476b7be04c7608"><td class="memTemplParams" colspan="2">template&lt;class T , bool Packed&gt; </td></tr>
<tr class="memitem:ae676fff5afb56c796e476b7be04c7608"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#ae676fff5afb56c796e476b7be04c7608">Abs</a> (const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;q)</td></tr>
<tr class="memdesc:ae676fff5afb56c796e476b7be04c7608"><td class="mdescLeft">&#160;</td><td class="mdescRight">The euclidean length of the vector of the 4 elements of the quaternion.  <a href="#ae676fff5afb56c796e476b7be04c7608">More...</a><br /></td></tr>
<tr class="separator:ae676fff5afb56c796e476b7be04c7608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e115a4eb960ba00446d63fb85e1e82"><td class="memTemplParams" colspan="2">template&lt;class T , bool Packed&gt; </td></tr>
<tr class="memitem:a97e115a4eb960ba00446d63fb85e1e82"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a97e115a4eb960ba00446d63fb85e1e82">Conjugate</a> (const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;q)</td></tr>
<tr class="memdesc:a97e115a4eb960ba00446d63fb85e1e82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negates the imaginary values of the quaternion.  <a href="#a97e115a4eb960ba00446d63fb85e1e82">More...</a><br /></td></tr>
<tr class="separator:a97e115a4eb960ba00446d63fb85e1e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93311c17c3a640e5730b9a9815e0c511"><td class="memTemplParams" colspan="2">template&lt;class T , bool Packed&gt; </td></tr>
<tr class="memitem:a93311c17c3a640e5730b9a9815e0c511"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a93311c17c3a640e5730b9a9815e0c511">Exp</a> (const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;q)</td></tr>
<tr class="memdesc:a93311c17c3a640e5730b9a9815e0c511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Natural quaternion exponentiation, base e.  <a href="#a93311c17c3a640e5730b9a9815e0c511">More...</a><br /></td></tr>
<tr class="separator:a93311c17c3a640e5730b9a9815e0c511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ca92ae75a9b13765cc4964c22ed087b"><td class="memTemplParams" colspan="2">template&lt;class T , bool Packed&gt; </td></tr>
<tr class="memitem:a9ca92ae75a9b13765cc4964c22ed087b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a9ca92ae75a9b13765cc4964c22ed087b">Log</a> (const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;q)</td></tr>
<tr class="memdesc:a9ca92ae75a9b13765cc4964c22ed087b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Natural quaternion logarithm, base e.  <a href="#a9ca92ae75a9b13765cc4964c22ed087b">More...</a><br /></td></tr>
<tr class="separator:a9ca92ae75a9b13765cc4964c22ed087b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af10142132fc984b872c1813f4379a68c"><td class="memTemplParams" colspan="2">template&lt;class T , bool Packed&gt; </td></tr>
<tr class="memitem:af10142132fc984b872c1813f4379a68c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#af10142132fc984b872c1813f4379a68c">Pow</a> (const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;q, T a)</td></tr>
<tr class="memdesc:af10142132fc984b872c1813f4379a68c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raises <em>q</em>  to the power of <em>a</em> .  <a href="#af10142132fc984b872c1813f4379a68c">More...</a><br /></td></tr>
<tr class="separator:af10142132fc984b872c1813f4379a68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a267ea5fb35c48ba3b24eb61709b4cb"><td class="memTemplParams" colspan="2">template&lt;class T , bool Packed&gt; </td></tr>
<tr class="memitem:a9a267ea5fb35c48ba3b24eb61709b4cb"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a9a267ea5fb35c48ba3b24eb61709b4cb">LengthSquared</a> (const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;q)</td></tr>
<tr class="memdesc:a9a267ea5fb35c48ba3b24eb61709b4cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the square of the absolute value.  <a href="#a9a267ea5fb35c48ba3b24eb61709b4cb">More...</a><br /></td></tr>
<tr class="separator:a9a267ea5fb35c48ba3b24eb61709b4cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2df7aaeca5a2cbb0461817066f19942c"><td class="memTemplParams" colspan="2">template&lt;class T , bool Packed&gt; </td></tr>
<tr class="memitem:a2df7aaeca5a2cbb0461817066f19942c"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a2df7aaeca5a2cbb0461817066f19942c">Length</a> (const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;q)</td></tr>
<tr class="memdesc:a2df7aaeca5a2cbb0461817066f19942c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the absolute value of the quaternion.  <a href="#a2df7aaeca5a2cbb0461817066f19942c">More...</a><br /></td></tr>
<tr class="separator:a2df7aaeca5a2cbb0461817066f19942c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd54869eab6bf47134e0c94100e12a12"><td class="memTemplParams" colspan="2">template&lt;class T , bool Packed&gt; </td></tr>
<tr class="memitem:afd54869eab6bf47134e0c94100e12a12"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#afd54869eab6bf47134e0c94100e12a12">Normalize</a> (const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;q)</td></tr>
<tr class="memdesc:afd54869eab6bf47134e0c94100e12a12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the unit quaternion of the same direction. Does not change this object.  <a href="#afd54869eab6bf47134e0c94100e12a12">More...</a><br /></td></tr>
<tr class="separator:afd54869eab6bf47134e0c94100e12a12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa32d6739219a5c7711fbd87b259f8449"><td class="memTemplParams" colspan="2">template&lt;class T , bool Packed&gt; </td></tr>
<tr class="memitem:aa32d6739219a5c7711fbd87b259f8449"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#aa32d6739219a5c7711fbd87b259f8449">Inverse</a> (const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;q)</td></tr>
<tr class="memdesc:aa32d6739219a5c7711fbd87b259f8449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the quaternion of opposite rotation.  <a href="#aa32d6739219a5c7711fbd87b259f8449">More...</a><br /></td></tr>
<tr class="separator:aa32d6739219a5c7711fbd87b259f8449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8063857014319059b0420565a4c17c29"><td class="memTemplParams" colspan="2">template&lt;class T , bool Packed&gt; </td></tr>
<tr class="memitem:a8063857014319059b0420565a4c17c29"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a8063857014319059b0420565a4c17c29">IsNormalized</a> (const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;q)</td></tr>
<tr class="memdesc:a8063857014319059b0420565a4c17c29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the quaternion is a unit quaternion, with some tolerance for floats.  <a href="#a8063857014319059b0420565a4c17c29">More...</a><br /></td></tr>
<tr class="separator:a8063857014319059b0420565a4c17c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76463c85cdf0a7ccdec59007ea0cad1a"><td class="memTemplParams" colspan="2">template&lt;class T , bool QPacked, bool PackedA&gt; </td></tr>
<tr class="memitem:a76463c85cdf0a7ccdec59007ea0cad1a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, 3, PackedA &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a76463c85cdf0a7ccdec59007ea0cad1a">operator*</a> (const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, QPacked &gt; &amp;q, const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, 3, PackedA &gt; &amp;vec)</td></tr>
<tr class="memdesc:a76463c85cdf0a7ccdec59007ea0cad1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates (and scales) vector by quaternion.  <a href="#a76463c85cdf0a7ccdec59007ea0cad1a">More...</a><br /></td></tr>
<tr class="separator:a76463c85cdf0a7ccdec59007ea0cad1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d103838eaf3bf01e93840e32a9c4fa"><td class="memTemplParams" colspan="2">template&lt;class T , bool QPacked, bool PackedA&gt; </td></tr>
<tr class="memitem:aa6d103838eaf3bf01e93840e32a9c4fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, 3, PackedA &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#aa6d103838eaf3bf01e93840e32a9c4fa">operator*</a> (const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, 3, PackedA &gt; &amp;vec, const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, QPacked &gt; &amp;q)</td></tr>
<tr class="memdesc:aa6d103838eaf3bf01e93840e32a9c4fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates (and scales) vector by quaternion.  <a href="#aa6d103838eaf3bf01e93840e32a9c4fa">More...</a><br /></td></tr>
<tr class="separator:aa6d103838eaf3bf01e93840e32a9c4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e4eda500a5f9130865cd40a88517fa1"><td class="memTemplParams" colspan="2">template&lt;class T , bool QPacked, bool PackedA&gt; </td></tr>
<tr class="memitem:a1e4eda500a5f9130865cd40a88517fa1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, 3, PackedA &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a1e4eda500a5f9130865cd40a88517fa1">operator*=</a> (<a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, 3, PackedA &gt; &amp;vec, const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, QPacked &gt; &amp;q)</td></tr>
<tr class="memdesc:a1e4eda500a5f9130865cd40a88517fa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates (and scales) vector by quaternion.  <a href="#a1e4eda500a5f9130865cd40a88517fa1">More...</a><br /></td></tr>
<tr class="separator:a1e4eda500a5f9130865cd40a88517fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f4425b0e0e1c5b87b7b89395b753f5"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemathter.html#af5f4425b0e0e1c5b87b7b89395b753f5">Identity</a> ()</td></tr>
<tr class="memdesc:af5f4425b0e0e1c5b87b7b89395b753f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an identity matrix or identity quaternion.  <a href="#af5f4425b0e0e1c5b87b7b89395b753f5">More...</a><br /></td></tr>
<tr class="separator:af5f4425b0e0e1c5b87b7b89395b753f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34cefefbfde338f47d9c3cf30b0f9121"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed&gt; </td></tr>
<tr class="memitem:a34cefefbfde338f47d9c3cf30b0f9121"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a34cefefbfde338f47d9c3cf30b0f9121">Orthographic</a> (const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;minBounds, const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;maxBounds, T projNearPlane=T(0), T projFarPlane=T(1))</td></tr>
<tr class="memdesc:a34cefefbfde338f47d9c3cf30b0f9121"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an orthographics projection matrix. The volume before projection is an axis-aligned hypercube and it is projected onto a unit hypercube.  <a href="#a34cefefbfde338f47d9c3cf30b0f9121">More...</a><br /></td></tr>
<tr class="separator:a34cefefbfde338f47d9c3cf30b0f9121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3697d4bcd477416233ae75a804183d6"><td class="memTemplParams" colspan="2">template&lt;class T , int DimMinus1, bool Packed&gt; </td></tr>
<tr class="memitem:ab3697d4bcd477416233ae75a804183d6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#ab3697d4bcd477416233ae75a804183d6">Perspective</a> (T fovX, const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, DimMinus1, Packed &gt; &amp;ratios, T nearPlane, T farPlane, T projNearPlane=T(0), T projFarPlane=T(1))</td></tr>
<tr class="memdesc:ab3697d4bcd477416233ae75a804183d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a perspective projection matrix.  <a href="#ab3697d4bcd477416233ae75a804183d6">More...</a><br /></td></tr>
<tr class="separator:ab3697d4bcd477416233ae75a804183d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b40cde8d2444be45a860db88c5aafe7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a3b40cde8d2444be45a860db88c5aafe7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a3b40cde8d2444be45a860db88c5aafe7">Perspective</a> (T fov, T nearPlane, T farPlane, T projNearPlane=T(0), T projFarPlane=T(1))</td></tr>
<tr class="memdesc:a3b40cde8d2444be45a860db88c5aafe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a 2D projection matrix.  <a href="#a3b40cde8d2444be45a860db88c5aafe7">More...</a><br /></td></tr>
<tr class="separator:a3b40cde8d2444be45a860db88c5aafe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b419d8527c72af06969250fcb7d9a4"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a27b419d8527c72af06969250fcb7d9a4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a27b419d8527c72af06969250fcb7d9a4">Perspective</a> (T fov, T aspectRatio, T nearPlane, T farPlane, T projNearPlane=T(0), T projFarPlane=T(1))</td></tr>
<tr class="memdesc:a27b419d8527c72af06969250fcb7d9a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a 3D projection matrix.  <a href="#a27b419d8527c72af06969250fcb7d9a4">More...</a><br /></td></tr>
<tr class="separator:a27b419d8527c72af06969250fcb7d9a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d1c36c125b7aea126c8fb657143791"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a97d1c36c125b7aea126c8fb657143791"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a97d1c36c125b7aea126c8fb657143791">Rotation</a> (const T &amp;angle)</td></tr>
<tr class="memdesc:a97d1c36c125b7aea126c8fb657143791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a 2D rotation matrix.  <a href="#a97d1c36c125b7aea126c8fb657143791">More...</a><br /></td></tr>
<tr class="separator:a97d1c36c125b7aea126c8fb657143791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad52def7749c5eec45874d788b5b093c5"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ad52def7749c5eec45874d788b5b093c5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#ad52def7749c5eec45874d788b5b093c5">RotationAxis</a> (T angle, int axis)</td></tr>
<tr class="memdesc:ad52def7749c5eec45874d788b5b093c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates around coordinate axis.  <a href="#ad52def7749c5eec45874d788b5b093c5">More...</a><br /></td></tr>
<tr class="separator:ad52def7749c5eec45874d788b5b093c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d79040271c24c63d4b114bf087680b"><td class="memTemplParams" colspan="2">template&lt;int Axis, class T &gt; </td></tr>
<tr class="memitem:a24d79040271c24c63d4b114bf087680b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a24d79040271c24c63d4b114bf087680b">RotationAxis</a> (T angle)</td></tr>
<tr class="memdesc:a24d79040271c24c63d4b114bf087680b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates around coordinate axis.  <a href="#a24d79040271c24c63d4b114bf087680b">More...</a><br /></td></tr>
<tr class="separator:a24d79040271c24c63d4b114bf087680b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83679fe823ebea3274dc70d69098eaa7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a83679fe823ebea3274dc70d69098eaa7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a83679fe823ebea3274dc70d69098eaa7">RotationX</a> (T angle)</td></tr>
<tr class="memdesc:a83679fe823ebea3274dc70d69098eaa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates around the X axis according to the right (left) hand rule.  <a href="#a83679fe823ebea3274dc70d69098eaa7">More...</a><br /></td></tr>
<tr class="separator:a83679fe823ebea3274dc70d69098eaa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a913a805426dab0a8272bf8abd43bffd1"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a913a805426dab0a8272bf8abd43bffd1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a913a805426dab0a8272bf8abd43bffd1">RotationY</a> (T angle)</td></tr>
<tr class="memdesc:a913a805426dab0a8272bf8abd43bffd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates around the Y axis according to the right (left) hand rule.  <a href="#a913a805426dab0a8272bf8abd43bffd1">More...</a><br /></td></tr>
<tr class="separator:a913a805426dab0a8272bf8abd43bffd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38bc8b68c120b23410ccb50d46670ddd"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a38bc8b68c120b23410ccb50d46670ddd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a38bc8b68c120b23410ccb50d46670ddd">RotationZ</a> (T angle)</td></tr>
<tr class="memdesc:a38bc8b68c120b23410ccb50d46670ddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates around the Z axis according to the right (left) hand rule.  <a href="#a38bc8b68c120b23410ccb50d46670ddd">More...</a><br /></td></tr>
<tr class="separator:a38bc8b68c120b23410ccb50d46670ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38dbd4e89c2f9631676f368c3732a975"><td class="memTemplParams" colspan="2">template&lt;int FirstAxis, int SecondAxis, int ThirdAxis, class T &gt; </td></tr>
<tr class="memitem:a38dbd4e89c2f9631676f368c3732a975"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a38dbd4e89c2f9631676f368c3732a975">RotationAxis3</a> (T angle0, T angle1, T angle2)</td></tr>
<tr class="memdesc:a38dbd4e89c2f9631676f368c3732a975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates around three axes in succession.  <a href="#a38dbd4e89c2f9631676f368c3732a975">More...</a><br /></td></tr>
<tr class="separator:a38dbd4e89c2f9631676f368c3732a975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae90205436e808c5e64fe6e7873740215"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae90205436e808c5e64fe6e7873740215"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#ae90205436e808c5e64fe6e7873740215">RotationEuler</a> (T z1, T x2, T z3)</td></tr>
<tr class="memdesc:ae90205436e808c5e64fe6e7873740215"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotation matrix from Euler angles. Rotations are Z-X-Z.  <a href="#ae90205436e808c5e64fe6e7873740215">More...</a><br /></td></tr>
<tr class="separator:ae90205436e808c5e64fe6e7873740215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a7333869dd8e51003ee8b6dd043e82"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a33a7333869dd8e51003ee8b6dd043e82"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a33a7333869dd8e51003ee8b6dd043e82">RotationRPY</a> (T x1, T y2, T z3)</td></tr>
<tr class="memdesc:a33a7333869dd8e51003ee8b6dd043e82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotation matrix from roll-pitch-yaw angles. Rotations are X-Y-Z.  <a href="#a33a7333869dd8e51003ee8b6dd043e82">More...</a><br /></td></tr>
<tr class="separator:a33a7333869dd8e51003ee8b6dd043e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff83202cf503ebf88db420cddbddc59e"><td class="memTemplParams" colspan="2">template&lt;class T , bool Vpacked, class U &gt; </td></tr>
<tr class="memitem:aff83202cf503ebf88db420cddbddc59e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#aff83202cf503ebf88db420cddbddc59e">RotationAxisAngle</a> (const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, 3, Vpacked &gt; &amp;axis, U angle)</td></tr>
<tr class="memdesc:aff83202cf503ebf88db420cddbddc59e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates around an arbitrary axis.  <a href="#aff83202cf503ebf88db420cddbddc59e">More...</a><br /></td></tr>
<tr class="separator:aff83202cf503ebf88db420cddbddc59e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da1838ffbfb7116d5bead5eb2442bf0"><td class="memTemplParams" colspan="2">template&lt;class T , int Rows, int Columns, eMatrixOrder Order, eMatrixLayout Layout, bool Packed&gt; </td></tr>
<tr class="memitem:a2da1838ffbfb7116d5bead5eb2442bf0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a2da1838ffbfb7116d5bead5eb2442bf0">IsRotationMatrix3D</a> (const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order, Layout, Packed &gt; &amp;m)</td></tr>
<tr class="memdesc:a2da1838ffbfb7116d5bead5eb2442bf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the matrix is a proper rotation matrix.  <a href="#a2da1838ffbfb7116d5bead5eb2442bf0">More...</a><br /></td></tr>
<tr class="separator:a2da1838ffbfb7116d5bead5eb2442bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d5e2b17284d01f055851818d97499f6"><td class="memTemplParams" colspan="2">template&lt;class Vt , int Vdim, bool Vpacked&gt; </td></tr>
<tr class="memitem:a7d5e2b17284d01f055851818d97499f6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a7d5e2b17284d01f055851818d97499f6">Scale</a> (const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; Vt, Vdim, Vpacked &gt; &amp;scale)</td></tr>
<tr class="memdesc:a7d5e2b17284d01f055851818d97499f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a scaling matrix.  <a href="#a7d5e2b17284d01f055851818d97499f6">More...</a><br /></td></tr>
<tr class="separator:a7d5e2b17284d01f055851818d97499f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a718ef64e5a81c34e042fcfe9a9e4f84c"><td class="memTemplParams" colspan="2">template&lt;class... Args, typename std::enable_if&lt;(traits::All&lt; traits::IsScalar, typename std::decay&lt; Args &gt;::type... &gt;::value), int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a718ef64e5a81c34e042fcfe9a9e4f84c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a718ef64e5a81c34e042fcfe9a9e4f84c">Scale</a> (Args &amp;&amp;... scales)</td></tr>
<tr class="memdesc:a718ef64e5a81c34e042fcfe9a9e4f84c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a scaling matrix.  <a href="#a718ef64e5a81c34e042fcfe9a9e4f84c">More...</a><br /></td></tr>
<tr class="separator:a718ef64e5a81c34e042fcfe9a9e4f84c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b6ed2a66d7a1971dbf86231f48fdbfe"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a9b6ed2a66d7a1971dbf86231f48fdbfe"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a9b6ed2a66d7a1971dbf86231f48fdbfe">Shear</a> (T slope, int principalAxis, int modulatorAxis)</td></tr>
<tr class="memdesc:a9b6ed2a66d7a1971dbf86231f48fdbfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a shear matrix.  <a href="#a9b6ed2a66d7a1971dbf86231f48fdbfe">More...</a><br /></td></tr>
<tr class="separator:a9b6ed2a66d7a1971dbf86231f48fdbfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4659304be5ecc5ec8cc11bea89de4409"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed&gt; </td></tr>
<tr class="memitem:a4659304be5ecc5ec8cc11bea89de4409"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a4659304be5ecc5ec8cc11bea89de4409">Translation</a> (const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;translation)</td></tr>
<tr class="memdesc:a4659304be5ecc5ec8cc11bea89de4409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a translation matrix.  <a href="#a4659304be5ecc5ec8cc11bea89de4409">More...</a><br /></td></tr>
<tr class="separator:a4659304be5ecc5ec8cc11bea89de4409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a674e0de9d767bc09f9749d558faf0575"><td class="memTemplParams" colspan="2">template&lt;class... Args, typename std::enable_if&lt;(traits::All&lt; traits::IsScalar, typename std::decay&lt; Args &gt;::type... &gt;::value), int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a674e0de9d767bc09f9749d558faf0575"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a674e0de9d767bc09f9749d558faf0575">Translation</a> (const Args &amp;... coordinates)</td></tr>
<tr class="memdesc:a674e0de9d767bc09f9749d558faf0575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a translation matrix.  <a href="#a674e0de9d767bc09f9749d558faf0575">More...</a><br /></td></tr>
<tr class="separator:a674e0de9d767bc09f9749d558faf0575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef09737154728355cbea9e8a7d78a7d"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed, size_t BaseDim, size_t FlipDim&gt; </td></tr>
<tr class="memitem:a4ef09737154728355cbea9e8a7d78a7d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a4ef09737154728355cbea9e8a7d78a7d">LookAt</a> (const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;eye, const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;target, const std::array&lt; <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt;, BaseDim &gt; &amp;bases, const std::array&lt; bool, FlipDim &gt; &amp;flipAxes)</td></tr>
<tr class="memdesc:a4ef09737154728355cbea9e8a7d78a7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a camera look-at matrix.  <a href="#a4ef09737154728355cbea9e8a7d78a7d">More...</a><br /></td></tr>
<tr class="separator:a4ef09737154728355cbea9e8a7d78a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a069e282382f9fb674f7b44f35d7b1eb9"><td class="memTemplParams" colspan="2">template&lt;class T , bool Packed&gt; </td></tr>
<tr class="memitem:a069e282382f9fb674f7b44f35d7b1eb9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a069e282382f9fb674f7b44f35d7b1eb9">LookAt</a> (const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, 2, Packed &gt; &amp;eye, const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, 2, Packed &gt; &amp;target, bool positiveYForward=<a class="el" href="namespacemathter.html#a22bd596866870bd3efc72306b6ac3430">true</a>, bool flipX=<a class="el" href="namespacemathter.html#af952fc7afa3d3600ade4d2c868344352">false</a>)</td></tr>
<tr class="memdesc:a069e282382f9fb674f7b44f35d7b1eb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a 2D look-at matrix.  <a href="#a069e282382f9fb674f7b44f35d7b1eb9">More...</a><br /></td></tr>
<tr class="separator:a069e282382f9fb674f7b44f35d7b1eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0853b75e7db69334f04371a190fd36ba"><td class="memTemplParams" colspan="2">template&lt;class T , bool Packed&gt; </td></tr>
<tr class="memitem:a0853b75e7db69334f04371a190fd36ba"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a0853b75e7db69334f04371a190fd36ba">LookAt</a> (const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, 3, Packed &gt; &amp;eye, const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, 3, Packed &gt; &amp;target, const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, 3, Packed &gt; &amp;up, bool positiveZForward=<a class="el" href="namespacemathter.html#a22bd596866870bd3efc72306b6ac3430">true</a>, bool flipX=<a class="el" href="namespacemathter.html#af952fc7afa3d3600ade4d2c868344352">false</a>, bool flipY=<a class="el" href="namespacemathter.html#af952fc7afa3d3600ade4d2c868344352">false</a>)</td></tr>
<tr class="memdesc:a0853b75e7db69334f04371a190fd36ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a 3D look-at matrix.  <a href="#a0853b75e7db69334f04371a190fd36ba">More...</a><br /></td></tr>
<tr class="separator:a0853b75e7db69334f04371a190fd36ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a596d124112904deeaf2837665ea61244"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a596d124112904deeaf2837665ea61244">Zero</a> ()</td></tr>
<tr class="memdesc:a596d124112904deeaf2837665ea61244"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a matrix with all elements zero.  <a href="#a596d124112904deeaf2837665ea61244">More...</a><br /></td></tr>
<tr class="separator:a596d124112904deeaf2837665ea61244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88ed58209428aadaa2b1f20fd3c7e4b"><td class="memTemplParams" colspan="2">template&lt;class Scalar &gt; </td></tr>
<tr class="memitem:af88ed58209428aadaa2b1f20fd3c7e4b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#af88ed58209428aadaa2b1f20fd3c7e4b">Rad2Deg</a> (Scalar rad)</td></tr>
<tr class="memdesc:af88ed58209428aadaa2b1f20fd3c7e4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts radians to degrees.  <a href="#af88ed58209428aadaa2b1f20fd3c7e4b">More...</a><br /></td></tr>
<tr class="separator:af88ed58209428aadaa2b1f20fd3c7e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f3d3eb6c6f391c1e3ce1dafe84bf2a7"><td class="memTemplParams" colspan="2">template&lt;class Scalar &gt; </td></tr>
<tr class="memitem:a0f3d3eb6c6f391c1e3ce1dafe84bf2a7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a0f3d3eb6c6f391c1e3ce1dafe84bf2a7">Deg2Rad</a> (Scalar deg)</td></tr>
<tr class="memdesc:a0f3d3eb6c6f391c1e3ce1dafe84bf2a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts degrees to radians.  <a href="#a0f3d3eb6c6f391c1e3ce1dafe84bf2a7">More...</a><br /></td></tr>
<tr class="separator:a0f3d3eb6c6f391c1e3ce1dafe84bf2a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72dba46a963b55a9931280baa47f797a"><td class="memTemplParams" colspan="2">template&lt;class Scalar &gt; </td></tr>
<tr class="memitem:a72dba46a963b55a9931280baa47f797a"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a72dba46a963b55a9931280baa47f797a">Clamp</a> (Scalar arg, Scalar lower, Scalar upper)</td></tr>
<tr class="memdesc:a72dba46a963b55a9931280baa47f797a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Limits arg to the range [lower, upper], making it either lower or upper if out of range.  <a href="#a72dba46a963b55a9931280baa47f797a">More...</a><br /></td></tr>
<tr class="separator:a72dba46a963b55a9931280baa47f797a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b0f6944099a5a9395f47f6a7d30c62b"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed&gt; </td></tr>
<tr class="memitem:a7b0f6944099a5a9395f47f6a7d30c62b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a7b0f6944099a5a9395f47f6a7d30c62b">Clamp</a> (const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;arg, T lower, T upper)</td></tr>
<tr class="memdesc:a7b0f6944099a5a9395f47f6a7d30c62b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clamps all elements of the vector according to the scalar clamp.  <a href="#a7b0f6944099a5a9395f47f6a7d30c62b">More...</a><br /></td></tr>
<tr class="separator:a7b0f6944099a5a9395f47f6a7d30c62b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0afd4bab2379fc2d4098b2f928b96b5a"><td class="memTemplParams" colspan="2">template&lt;class Scalar &gt; </td></tr>
<tr class="memitem:a0afd4bab2379fc2d4098b2f928b96b5a"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a0afd4bab2379fc2d4098b2f928b96b5a">Saturate</a> (Scalar arg)</td></tr>
<tr class="memdesc:a0afd4bab2379fc2d4098b2f928b96b5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clamps argument into range [0,1].  <a href="#a0afd4bab2379fc2d4098b2f928b96b5a">More...</a><br /></td></tr>
<tr class="separator:a0afd4bab2379fc2d4098b2f928b96b5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a806c90f50a336e7040dcc2d5037bebf3"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed&gt; </td></tr>
<tr class="memitem:a806c90f50a336e7040dcc2d5037bebf3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a806c90f50a336e7040dcc2d5037bebf3">Saturate</a> (const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;arg)</td></tr>
<tr class="memdesc:a806c90f50a336e7040dcc2d5037bebf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clamps all elements into range [0,1].  <a href="#a806c90f50a336e7040dcc2d5037bebf3">More...</a><br /></td></tr>
<tr class="separator:a806c90f50a336e7040dcc2d5037bebf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae27f4e5caf5f1f7b0e8f95b27cdc81a1"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed&gt; </td></tr>
<tr class="memitem:ae27f4e5caf5f1f7b0e8f95b27cdc81a1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#ae27f4e5caf5f1f7b0e8f95b27cdc81a1">operator*</a> (const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;lhs, const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ae27f4e5caf5f1f7b0e8f95b27cdc81a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise (Hadamard) vector product.  <a href="#ae27f4e5caf5f1f7b0e8f95b27cdc81a1">More...</a><br /></td></tr>
<tr class="separator:ae27f4e5caf5f1f7b0e8f95b27cdc81a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba1f61dcdd8f6c4f7ee1005cacb5c4b"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed&gt; </td></tr>
<tr class="memitem:acba1f61dcdd8f6c4f7ee1005cacb5c4b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#acba1f61dcdd8f6c4f7ee1005cacb5c4b">operator/</a> (const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;lhs, const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;rhs)</td></tr>
<tr class="memdesc:acba1f61dcdd8f6c4f7ee1005cacb5c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise vector division.  <a href="#acba1f61dcdd8f6c4f7ee1005cacb5c4b">More...</a><br /></td></tr>
<tr class="separator:acba1f61dcdd8f6c4f7ee1005cacb5c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee542fc0f48ea6211c1df5c6862beb2"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed&gt; </td></tr>
<tr class="memitem:a8ee542fc0f48ea6211c1df5c6862beb2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a8ee542fc0f48ea6211c1df5c6862beb2">operator+</a> (const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;lhs, const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a8ee542fc0f48ea6211c1df5c6862beb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise vector addition.  <a href="#a8ee542fc0f48ea6211c1df5c6862beb2">More...</a><br /></td></tr>
<tr class="separator:a8ee542fc0f48ea6211c1df5c6862beb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac44a2a08922a0d27b872bab73ac74e3b"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed&gt; </td></tr>
<tr class="memitem:ac44a2a08922a0d27b872bab73ac74e3b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#ac44a2a08922a0d27b872bab73ac74e3b">operator-</a> (const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;lhs, const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ac44a2a08922a0d27b872bab73ac74e3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise vector subtraction.  <a href="#ac44a2a08922a0d27b872bab73ac74e3b">More...</a><br /></td></tr>
<tr class="separator:ac44a2a08922a0d27b872bab73ac74e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af943c9e61314c8a64d967755f5db2d91"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed&gt; </td></tr>
<tr class="memitem:af943c9e61314c8a64d967755f5db2d91"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#af943c9e61314c8a64d967755f5db2d91">operator*=</a> (<a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;lhs, const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;rhs)</td></tr>
<tr class="memdesc:af943c9e61314c8a64d967755f5db2d91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise (Hadamard) vector product.  <a href="#af943c9e61314c8a64d967755f5db2d91">More...</a><br /></td></tr>
<tr class="separator:af943c9e61314c8a64d967755f5db2d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fe8d6c35cacd5561c61e19cd7ebd414"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed&gt; </td></tr>
<tr class="memitem:a6fe8d6c35cacd5561c61e19cd7ebd414"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a6fe8d6c35cacd5561c61e19cd7ebd414">operator/=</a> (<a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;lhs, const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a6fe8d6c35cacd5561c61e19cd7ebd414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise vector division.  <a href="#a6fe8d6c35cacd5561c61e19cd7ebd414">More...</a><br /></td></tr>
<tr class="separator:a6fe8d6c35cacd5561c61e19cd7ebd414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2942ded99e880fae0ac9d43bca05c72b"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed&gt; </td></tr>
<tr class="memitem:a2942ded99e880fae0ac9d43bca05c72b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a2942ded99e880fae0ac9d43bca05c72b">operator+=</a> (<a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;lhs, const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a2942ded99e880fae0ac9d43bca05c72b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise vector addition.  <a href="#a2942ded99e880fae0ac9d43bca05c72b">More...</a><br /></td></tr>
<tr class="separator:a2942ded99e880fae0ac9d43bca05c72b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4fe0e48ee495e2e209fbe68837a556f"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed&gt; </td></tr>
<tr class="memitem:ac4fe0e48ee495e2e209fbe68837a556f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#ac4fe0e48ee495e2e209fbe68837a556f">operator-=</a> (<a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;lhs, const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ac4fe0e48ee495e2e209fbe68837a556f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise vector subtraction.  <a href="#ac4fe0e48ee495e2e209fbe68837a556f">More...</a><br /></td></tr>
<tr class="separator:ac4fe0e48ee495e2e209fbe68837a556f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c9396bcb5b8f3a4045413e66ca24137"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed&gt; </td></tr>
<tr class="memitem:a9c9396bcb5b8f3a4045413e66ca24137"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a9c9396bcb5b8f3a4045413e66ca24137">operator*=</a> (<a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;lhs, T rhs)</td></tr>
<tr class="memdesc:a9c9396bcb5b8f3a4045413e66ca24137"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales the vector by <em>rhs</em> .  <a href="#a9c9396bcb5b8f3a4045413e66ca24137">More...</a><br /></td></tr>
<tr class="separator:a9c9396bcb5b8f3a4045413e66ca24137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8065ea26fc434fd242bbec48ecb915aa"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed&gt; </td></tr>
<tr class="memitem:a8065ea26fc434fd242bbec48ecb915aa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a8065ea26fc434fd242bbec48ecb915aa">operator/=</a> (<a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;lhs, T rhs)</td></tr>
<tr class="memdesc:a8065ea26fc434fd242bbec48ecb915aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales the vector by 1/<em>rhs</em> .  <a href="#a8065ea26fc434fd242bbec48ecb915aa">More...</a><br /></td></tr>
<tr class="separator:a8065ea26fc434fd242bbec48ecb915aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83276761b0ee3f542f2fe5928c4d7464"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed&gt; </td></tr>
<tr class="memitem:a83276761b0ee3f542f2fe5928c4d7464"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a83276761b0ee3f542f2fe5928c4d7464">operator+=</a> (<a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;lhs, T rhs)</td></tr>
<tr class="memdesc:a83276761b0ee3f542f2fe5928c4d7464"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds <em>rhs</em>  to each element of the vector.  <a href="#a83276761b0ee3f542f2fe5928c4d7464">More...</a><br /></td></tr>
<tr class="separator:a83276761b0ee3f542f2fe5928c4d7464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d7e64be6f5ab2ab1782341b33933060"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed&gt; </td></tr>
<tr class="memitem:a8d7e64be6f5ab2ab1782341b33933060"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a8d7e64be6f5ab2ab1782341b33933060">operator-=</a> (<a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;lhs, T rhs)</td></tr>
<tr class="memdesc:a8d7e64be6f5ab2ab1782341b33933060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts <em>rhs</em>  from each element of the vector.  <a href="#a8d7e64be6f5ab2ab1782341b33933060">More...</a><br /></td></tr>
<tr class="separator:a8d7e64be6f5ab2ab1782341b33933060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab909c21a9a8ee10650a07058dc640206"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed&gt; </td></tr>
<tr class="memitem:ab909c21a9a8ee10650a07058dc640206"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#ab909c21a9a8ee10650a07058dc640206">operator*</a> (const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;lhs, T rhs)</td></tr>
<tr class="memdesc:ab909c21a9a8ee10650a07058dc640206"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales the vector by <em>rhs</em> .  <a href="#ab909c21a9a8ee10650a07058dc640206">More...</a><br /></td></tr>
<tr class="separator:ab909c21a9a8ee10650a07058dc640206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90b27e7c826d6293621189f0b0878d0e"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed&gt; </td></tr>
<tr class="memitem:a90b27e7c826d6293621189f0b0878d0e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a90b27e7c826d6293621189f0b0878d0e">operator/</a> (const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;lhs, T rhs)</td></tr>
<tr class="memdesc:a90b27e7c826d6293621189f0b0878d0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales the vector by 1/<em>rhs</em> .  <a href="#a90b27e7c826d6293621189f0b0878d0e">More...</a><br /></td></tr>
<tr class="separator:a90b27e7c826d6293621189f0b0878d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a555ffa28c9358dccaefa2519c35343ed"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed&gt; </td></tr>
<tr class="memitem:a555ffa28c9358dccaefa2519c35343ed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a555ffa28c9358dccaefa2519c35343ed">operator+</a> (const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;lhs, T rhs)</td></tr>
<tr class="memdesc:a555ffa28c9358dccaefa2519c35343ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds <em>rhs</em>  to each element of the vector.  <a href="#a555ffa28c9358dccaefa2519c35343ed">More...</a><br /></td></tr>
<tr class="separator:a555ffa28c9358dccaefa2519c35343ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b82d45d19daecaa159de246f2363b6e"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed&gt; </td></tr>
<tr class="memitem:a0b82d45d19daecaa159de246f2363b6e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a0b82d45d19daecaa159de246f2363b6e">operator-</a> (const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;lhs, T rhs)</td></tr>
<tr class="memdesc:a0b82d45d19daecaa159de246f2363b6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts <em>rhs</em>  from each element of the vector.  <a href="#a0b82d45d19daecaa159de246f2363b6e">More...</a><br /></td></tr>
<tr class="separator:a0b82d45d19daecaa159de246f2363b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f27811e5f6cb8bb12f0042f07a67283"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed, class U , class  = typename std::enable_if&lt;std::is_convertible&lt;U, T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a8f27811e5f6cb8bb12f0042f07a67283"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a8f27811e5f6cb8bb12f0042f07a67283">operator*</a> (U lhs, const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a8f27811e5f6cb8bb12f0042f07a67283"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales vector by <em>lhs</em> .  <a href="#a8f27811e5f6cb8bb12f0042f07a67283">More...</a><br /></td></tr>
<tr class="separator:a8f27811e5f6cb8bb12f0042f07a67283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa72e6a390e648aca26ad185ce57e9bca"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed, class U , class  = typename std::enable_if&lt;std::is_convertible&lt;U, T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:aa72e6a390e648aca26ad185ce57e9bca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#aa72e6a390e648aca26ad185ce57e9bca">operator+</a> (U lhs, const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aa72e6a390e648aca26ad185ce57e9bca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds <em>lhs</em>  to all elements of the vector.  <a href="#aa72e6a390e648aca26ad185ce57e9bca">More...</a><br /></td></tr>
<tr class="separator:aa72e6a390e648aca26ad185ce57e9bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbd62ab69cfe32cf2d5859208bfb061e"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed, class U , class  = typename std::enable_if&lt;std::is_convertible&lt;U, T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:acbd62ab69cfe32cf2d5859208bfb061e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#acbd62ab69cfe32cf2d5859208bfb061e">operator-</a> (U lhs, const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;rhs)</td></tr>
<tr class="memdesc:acbd62ab69cfe32cf2d5859208bfb061e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a vector with <em>lhs</em>  as all elements, then subtracts <em>rhs</em>  from it.  <a href="#acbd62ab69cfe32cf2d5859208bfb061e">More...</a><br /></td></tr>
<tr class="separator:acbd62ab69cfe32cf2d5859208bfb061e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab1b715f156a9375f8c6a59ab9f1e18c"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed, class U , class  = typename std::enable_if&lt;std::is_convertible&lt;U, T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:aab1b715f156a9375f8c6a59ab9f1e18c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#aab1b715f156a9375f8c6a59ab9f1e18c">operator/</a> (U lhs, const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aab1b715f156a9375f8c6a59ab9f1e18c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a vector with <em>lhs</em>  as all elements, then divides it by <em>rhs</em> .  <a href="#aab1b715f156a9375f8c6a59ab9f1e18c">More...</a><br /></td></tr>
<tr class="separator:aab1b715f156a9375f8c6a59ab9f1e18c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae615e37db0d75b776b7ead89a72b532c"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed&gt; </td></tr>
<tr class="memitem:ae615e37db0d75b776b7ead89a72b532c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#ae615e37db0d75b776b7ead89a72b532c">MultiplyAdd</a> (const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;a, const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;b, const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;c)</td></tr>
<tr class="memdesc:ae615e37db0d75b776b7ead89a72b532c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return (a*b)+c. Performs MAD or FMA if supported by target architecture.  <a href="#ae615e37db0d75b776b7ead89a72b532c">More...</a><br /></td></tr>
<tr class="separator:ae615e37db0d75b776b7ead89a72b532c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a812bd5de504beb601ecbf016ab7a7ef7"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed&gt; </td></tr>
<tr class="memitem:a812bd5de504beb601ecbf016ab7a7ef7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a812bd5de504beb601ecbf016ab7a7ef7">operator-</a> (const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;arg)</td></tr>
<tr class="memdesc:a812bd5de504beb601ecbf016ab7a7ef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negates all elements of the vector.  <a href="#a812bd5de504beb601ecbf016ab7a7ef7">More...</a><br /></td></tr>
<tr class="separator:a812bd5de504beb601ecbf016ab7a7ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a310dde6da1864848cde57eb67760d85c"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed&gt; </td></tr>
<tr class="memitem:a310dde6da1864848cde57eb67760d85c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a310dde6da1864848cde57eb67760d85c">operator+</a> (const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;arg)</td></tr>
<tr class="memdesc:a310dde6da1864848cde57eb67760d85c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional plus sign, leaves the vector as is.  <a href="#a310dde6da1864848cde57eb67760d85c">More...</a><br /></td></tr>
<tr class="separator:a310dde6da1864848cde57eb67760d85c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89c6a7301562f98494eb6c3139a59d5f"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed, int... Indices&gt; </td></tr>
<tr class="memitem:a89c6a7301562f98494eb6c3139a59d5f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; Dim==sizeof...(Indices), <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a89c6a7301562f98494eb6c3139a59d5f">operator*</a> (const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;v, const <a class="el" href="classmathter_1_1_swizzle.html">Swizzle</a>&lt; T, Indices... &gt; &amp;s)</td></tr>
<tr class="separator:a89c6a7301562f98494eb6c3139a59d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5397fb937f96f1abaee2023fbb1c73e6"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed, int... Indices&gt; </td></tr>
<tr class="memitem:a5397fb937f96f1abaee2023fbb1c73e6"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; Dim==sizeof...(Indices), <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a5397fb937f96f1abaee2023fbb1c73e6">operator/</a> (const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;v, const <a class="el" href="classmathter_1_1_swizzle.html">Swizzle</a>&lt; T, Indices... &gt; &amp;s)</td></tr>
<tr class="separator:a5397fb937f96f1abaee2023fbb1c73e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e418fdd4164a02162ed1c0970db91ea"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed, int... Indices&gt; </td></tr>
<tr class="memitem:a3e418fdd4164a02162ed1c0970db91ea"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; Dim==sizeof...(Indices), <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a3e418fdd4164a02162ed1c0970db91ea">operator+</a> (const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;v, const <a class="el" href="classmathter_1_1_swizzle.html">Swizzle</a>&lt; T, Indices... &gt; &amp;s)</td></tr>
<tr class="separator:a3e418fdd4164a02162ed1c0970db91ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac47819028b6efe4b59e7e393c8e0d148"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed, int... Indices&gt; </td></tr>
<tr class="memitem:ac47819028b6efe4b59e7e393c8e0d148"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; Dim==sizeof...(Indices), <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#ac47819028b6efe4b59e7e393c8e0d148">operator-</a> (const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;v, const <a class="el" href="classmathter_1_1_swizzle.html">Swizzle</a>&lt; T, Indices... &gt; &amp;s)</td></tr>
<tr class="separator:ac47819028b6efe4b59e7e393c8e0d148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad76cd5d70a7924367f49161355bd17b8"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed, int... Indices&gt; </td></tr>
<tr class="memitem:ad76cd5d70a7924367f49161355bd17b8"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; Dim==sizeof...(Indices), <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#ad76cd5d70a7924367f49161355bd17b8">operator*</a> (const <a class="el" href="classmathter_1_1_swizzle.html">Swizzle</a>&lt; T, Indices... &gt; &amp;s, const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;v)</td></tr>
<tr class="separator:ad76cd5d70a7924367f49161355bd17b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d45d68f369a47163eb4bdd2ee9cd17d"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed, int... Indices&gt; </td></tr>
<tr class="memitem:a1d45d68f369a47163eb4bdd2ee9cd17d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; Dim==sizeof...(Indices), <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a1d45d68f369a47163eb4bdd2ee9cd17d">operator/</a> (const <a class="el" href="classmathter_1_1_swizzle.html">Swizzle</a>&lt; T, Indices... &gt; &amp;s, const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;v)</td></tr>
<tr class="separator:a1d45d68f369a47163eb4bdd2ee9cd17d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0144ef90450f567ae0b5a4f5354b879"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed, int... Indices&gt; </td></tr>
<tr class="memitem:ab0144ef90450f567ae0b5a4f5354b879"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; Dim==sizeof...(Indices), <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#ab0144ef90450f567ae0b5a4f5354b879">operator+</a> (const <a class="el" href="classmathter_1_1_swizzle.html">Swizzle</a>&lt; T, Indices... &gt; &amp;s, const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;v)</td></tr>
<tr class="separator:ab0144ef90450f567ae0b5a4f5354b879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de36293ddab4f9e5016978eda3ec7e9"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed, int... Indices&gt; </td></tr>
<tr class="memitem:a6de36293ddab4f9e5016978eda3ec7e9"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; Dim==sizeof...(Indices), <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a6de36293ddab4f9e5016978eda3ec7e9">operator-</a> (const <a class="el" href="classmathter_1_1_swizzle.html">Swizzle</a>&lt; T, Indices... &gt; &amp;s, const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;v)</td></tr>
<tr class="separator:a6de36293ddab4f9e5016978eda3ec7e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50493de58b06709a0c20e3ffbb53f331"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed, int... Indices&gt; </td></tr>
<tr class="memitem:a50493de58b06709a0c20e3ffbb53f331"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; Dim==sizeof...(Indices), <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a50493de58b06709a0c20e3ffbb53f331">operator*=</a> (const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;v, const <a class="el" href="classmathter_1_1_swizzle.html">Swizzle</a>&lt; T, Indices... &gt; &amp;s)</td></tr>
<tr class="separator:a50493de58b06709a0c20e3ffbb53f331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23d6c20aae639976958fbd56779d0737"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed, int... Indices&gt; </td></tr>
<tr class="memitem:a23d6c20aae639976958fbd56779d0737"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; Dim==sizeof...(Indices), <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a23d6c20aae639976958fbd56779d0737">operator/=</a> (const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;v, const <a class="el" href="classmathter_1_1_swizzle.html">Swizzle</a>&lt; T, Indices... &gt; &amp;s)</td></tr>
<tr class="separator:a23d6c20aae639976958fbd56779d0737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7626db67fb5d31ed57f8c3c99bb5afca"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed, int... Indices&gt; </td></tr>
<tr class="memitem:a7626db67fb5d31ed57f8c3c99bb5afca"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; Dim==sizeof...(Indices), <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a7626db67fb5d31ed57f8c3c99bb5afca">operator+=</a> (const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;v, const <a class="el" href="classmathter_1_1_swizzle.html">Swizzle</a>&lt; T, Indices... &gt; &amp;s)</td></tr>
<tr class="separator:a7626db67fb5d31ed57f8c3c99bb5afca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab70a4e1bd5b3f0a73421383ad4f63f1d"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed, int... Indices&gt; </td></tr>
<tr class="memitem:ab70a4e1bd5b3f0a73421383ad4f63f1d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; Dim==sizeof...(Indices), <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#ab70a4e1bd5b3f0a73421383ad4f63f1d">operator-=</a> (const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;v, const <a class="el" href="classmathter_1_1_swizzle.html">Swizzle</a>&lt; T, Indices... &gt; &amp;s)</td></tr>
<tr class="separator:ab70a4e1bd5b3f0a73421383ad4f63f1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addf4d4417129f113c9787759a5400f36"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed&gt; </td></tr>
<tr class="memitem:addf4d4417129f113c9787759a5400f36"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#addf4d4417129f113c9787759a5400f36">operator==</a> (const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;lhs, const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;rhs)</td></tr>
<tr class="memdesc:addf4d4417129f113c9787759a5400f36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exactly compares two vectors.  <a href="#addf4d4417129f113c9787759a5400f36">More...</a><br /></td></tr>
<tr class="separator:addf4d4417129f113c9787759a5400f36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a659331c8864c15fcd1f0676026ded"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed&gt; </td></tr>
<tr class="memitem:a93a659331c8864c15fcd1f0676026ded"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a93a659331c8864c15fcd1f0676026ded">operator!=</a> (const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;lhs, const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a93a659331c8864c15fcd1f0676026ded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exactly compares two vectors.  <a href="#a93a659331c8864c15fcd1f0676026ded">More...</a><br /></td></tr>
<tr class="separator:a93a659331c8864c15fcd1f0676026ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058a01e46b51c3ad1982ec703f700395"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed, class U &gt; </td></tr>
<tr class="memitem:a058a01e46b51c3ad1982ec703f700395"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_vector.html">mathter::Vector</a>&lt; T, Dim+1, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a058a01e46b51c3ad1982ec703f700395">operator|</a> (const <a class="el" href="classmathter_1_1_vector.html">mathter::Vector</a>&lt; T, Dim, Packed &gt; &amp;lhs, U rhs)</td></tr>
<tr class="memdesc:a058a01e46b51c3ad1982ec703f700395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates the arguments, and returns the concatenated vector.  <a href="#a058a01e46b51c3ad1982ec703f700395">More...</a><br /></td></tr>
<tr class="separator:a058a01e46b51c3ad1982ec703f700395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a0dd583fe8092ee4b40d0f4dfabd07d"><td class="memTemplParams" colspan="2">template&lt;class T1 , int Dim1, class T2 , int Dim2, bool Packed&gt; </td></tr>
<tr class="memitem:a2a0dd583fe8092ee4b40d0f4dfabd07d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_vector.html">mathter::Vector</a>&lt; T1, Dim1+Dim2, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a2a0dd583fe8092ee4b40d0f4dfabd07d">operator|</a> (const <a class="el" href="classmathter_1_1_vector.html">mathter::Vector</a>&lt; T1, Dim1, Packed &gt; &amp;lhs, const <a class="el" href="classmathter_1_1_vector.html">mathter::Vector</a>&lt; T2, Dim2, Packed &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a2a0dd583fe8092ee4b40d0f4dfabd07d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates the arguments, and returns the concatenated vector.  <a href="#a2a0dd583fe8092ee4b40d0f4dfabd07d">More...</a><br /></td></tr>
<tr class="separator:a2a0dd583fe8092ee4b40d0f4dfabd07d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f2a61053048268cab43b6cc49854d22"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed, class U &gt; </td></tr>
<tr class="memitem:a4f2a61053048268cab43b6cc49854d22"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_vector.html">mathter::Vector</a>&lt; T, Dim+1, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a4f2a61053048268cab43b6cc49854d22">operator|</a> (U lhs, const <a class="el" href="classmathter_1_1_vector.html">mathter::Vector</a>&lt; T, Dim, Packed &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a4f2a61053048268cab43b6cc49854d22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates the arguments, and returns the concatenated vector.  <a href="#a4f2a61053048268cab43b6cc49854d22">More...</a><br /></td></tr>
<tr class="separator:a4f2a61053048268cab43b6cc49854d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab554eacfac281c6e6f71abd26859785e"><td class="memTemplParams" colspan="2">template&lt;class T1 , int... Indices1, class T2 , int... Indices2&gt; </td></tr>
<tr class="memitem:ab554eacfac281c6e6f71abd26859785e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T1, sizeof...(Indices2)+sizeof...(Indices2), <a class="el" href="namespacemathter.html#af952fc7afa3d3600ade4d2c868344352">false</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#ab554eacfac281c6e6f71abd26859785e">operator|</a> (const <a class="el" href="classmathter_1_1_swizzle.html">Swizzle</a>&lt; T1, Indices1... &gt; &amp;lhs, const <a class="el" href="classmathter_1_1_swizzle.html">Swizzle</a>&lt; T2, Indices2... &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ab554eacfac281c6e6f71abd26859785e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates the arguments, and returns the concatenated vector.  <a href="#ab554eacfac281c6e6f71abd26859785e">More...</a><br /></td></tr>
<tr class="separator:ab554eacfac281c6e6f71abd26859785e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c07d44bdaa19730c8f644af773eddc"><td class="memTemplParams" colspan="2">template&lt;class T1 , int... Indices1, class T2 , int Dim, bool Packed&gt; </td></tr>
<tr class="memitem:a93c07d44bdaa19730c8f644af773eddc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T1, sizeof...(Indices1)+Dim, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a93c07d44bdaa19730c8f644af773eddc">operator|</a> (const <a class="el" href="classmathter_1_1_swizzle.html">Swizzle</a>&lt; T1, Indices1... &gt; &amp;lhs, const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T2, Dim, Packed &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a93c07d44bdaa19730c8f644af773eddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates the arguments, and returns the concatenated vector.  <a href="#a93c07d44bdaa19730c8f644af773eddc">More...</a><br /></td></tr>
<tr class="separator:a93c07d44bdaa19730c8f644af773eddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2836c40fabc9a09ea543d912d0d323d"><td class="memTemplParams" colspan="2">template&lt;class T1 , int... Indices1, class T2 , int Dim, bool Packed&gt; </td></tr>
<tr class="memitem:ae2836c40fabc9a09ea543d912d0d323d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T1, sizeof...(Indices1)+Dim, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#ae2836c40fabc9a09ea543d912d0d323d">operator|</a> (const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T2, Dim, Packed &gt; &amp;lhs, const <a class="el" href="classmathter_1_1_swizzle.html">Swizzle</a>&lt; T1, Indices1... &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ae2836c40fabc9a09ea543d912d0d323d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates the arguments, and returns the concatenated vector.  <a href="#ae2836c40fabc9a09ea543d912d0d323d">More...</a><br /></td></tr>
<tr class="separator:ae2836c40fabc9a09ea543d912d0d323d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad69e1d654153673b5fe705b4758a6089"><td class="memTemplParams" colspan="2">template&lt;class T1 , int... Indices1, class U &gt; </td></tr>
<tr class="memitem:ad69e1d654153673b5fe705b4758a6089"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T1, sizeof...(Indices1)+1, <a class="el" href="namespacemathter.html#af952fc7afa3d3600ade4d2c868344352">false</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#ad69e1d654153673b5fe705b4758a6089">operator|</a> (const <a class="el" href="classmathter_1_1_swizzle.html">Swizzle</a>&lt; T1, Indices1... &gt; &amp;lhs, U rhs)</td></tr>
<tr class="memdesc:ad69e1d654153673b5fe705b4758a6089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates the arguments, and returns the concatenated vector.  <a href="#ad69e1d654153673b5fe705b4758a6089">More...</a><br /></td></tr>
<tr class="separator:ad69e1d654153673b5fe705b4758a6089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e884298d7c1dce0c22431883a90e1a"><td class="memTemplParams" colspan="2">template&lt;class T1 , int... Indices1, class U &gt; </td></tr>
<tr class="memitem:a90e884298d7c1dce0c22431883a90e1a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T1, sizeof...(Indices1)+1, <a class="el" href="namespacemathter.html#af952fc7afa3d3600ade4d2c868344352">false</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a90e884298d7c1dce0c22431883a90e1a">operator|</a> (U lhs, const <a class="el" href="classmathter_1_1_swizzle.html">Swizzle</a>&lt; T1, Indices1... &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a90e884298d7c1dce0c22431883a90e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates the arguments, and returns the concatenated vector.  <a href="#a90e884298d7c1dce0c22431883a90e1a">More...</a><br /></td></tr>
<tr class="separator:a90e884298d7c1dce0c22431883a90e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4535d355930f4386e0f389207e0aa8a3"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed&gt; </td></tr>
<tr class="memitem:a4535d355930f4386e0f389207e0aa8a3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a4535d355930f4386e0f389207e0aa8a3">IsNullvector</a> (const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;v)</td></tr>
<tr class="memdesc:a4535d355930f4386e0f389207e0aa8a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the vector's length is too small for precise calculations (i.e. normalization).  <a href="#a4535d355930f4386e0f389207e0aa8a3">More...</a><br /></td></tr>
<tr class="separator:a4535d355930f4386e0f389207e0aa8a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdbed2d415b612e7eb8e4ad4a5de4128"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed&gt; </td></tr>
<tr class="memitem:acdbed2d415b612e7eb8e4ad4a5de4128"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#acdbed2d415b612e7eb8e4ad4a5de4128">LengthSquared</a> (const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;v)</td></tr>
<tr class="memdesc:acdbed2d415b612e7eb8e4ad4a5de4128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the squared length of the vector.  <a href="#acdbed2d415b612e7eb8e4ad4a5de4128">More...</a><br /></td></tr>
<tr class="separator:acdbed2d415b612e7eb8e4ad4a5de4128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e4484e9bfcc0f406aa7dea4e95e6b7a"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed&gt; </td></tr>
<tr class="memitem:a7e4484e9bfcc0f406aa7dea4e95e6b7a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a7e4484e9bfcc0f406aa7dea4e95e6b7a">Length</a> (const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;v)</td></tr>
<tr class="memdesc:a7e4484e9bfcc0f406aa7dea4e95e6b7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the vector.  <a href="#a7e4484e9bfcc0f406aa7dea4e95e6b7a">More...</a><br /></td></tr>
<tr class="separator:a7e4484e9bfcc0f406aa7dea4e95e6b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6319585c3b16a6d70b0bbd3ab44814df"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed&gt; </td></tr>
<tr class="memitem:a6319585c3b16a6d70b0bbd3ab44814df"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a6319585c3b16a6d70b0bbd3ab44814df">LengthPrecise</a> (const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;v)</td></tr>
<tr class="memdesc:a6319585c3b16a6d70b0bbd3ab44814df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the vector, avoids overflow and underflow, so it's more expensive.  <a href="#a6319585c3b16a6d70b0bbd3ab44814df">More...</a><br /></td></tr>
<tr class="separator:a6319585c3b16a6d70b0bbd3ab44814df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a556b6ef96f335976bbc04a8f93eee5a1"><td class="memTemplParams" colspan="2">template&lt;class T , class U , int Dim, bool Packed1, bool Packed2&gt; </td></tr>
<tr class="memitem:a556b6ef96f335976bbc04a8f93eee5a1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a556b6ef96f335976bbc04a8f93eee5a1">Distance</a> (const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed1 &gt; &amp;lhs, const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; U, Dim, Packed2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a556b6ef96f335976bbc04a8f93eee5a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the euclidean distance between to vectors.  <a href="#a556b6ef96f335976bbc04a8f93eee5a1">More...</a><br /></td></tr>
<tr class="separator:a556b6ef96f335976bbc04a8f93eee5a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6343e463fffcecd32ec6336859226a1"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed&gt; </td></tr>
<tr class="memitem:af6343e463fffcecd32ec6336859226a1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#af6343e463fffcecd32ec6336859226a1">Normalize</a> (const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;v)</td></tr>
<tr class="memdesc:af6343e463fffcecd32ec6336859226a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a unit vector, but keeps direction.  <a href="#af6343e463fffcecd32ec6336859226a1">More...</a><br /></td></tr>
<tr class="separator:af6343e463fffcecd32ec6336859226a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeab38015d970ee421f4c2a88284a1d1"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed&gt; </td></tr>
<tr class="memitem:abeab38015d970ee421f4c2a88284a1d1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#abeab38015d970ee421f4c2a88284a1d1">IsNormalized</a> (const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;v)</td></tr>
<tr class="memdesc:abeab38015d970ee421f4c2a88284a1d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the vector is unit vector. There's some tolerance due to floating points.  <a href="#abeab38015d970ee421f4c2a88284a1d1">More...</a><br /></td></tr>
<tr class="separator:abeab38015d970ee421f4c2a88284a1d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a633f39207a943dadb8e22103032fd092"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed&gt; </td></tr>
<tr class="memitem:a633f39207a943dadb8e22103032fd092"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a633f39207a943dadb8e22103032fd092">SafeNormalize</a> (const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;v)</td></tr>
<tr class="memdesc:a633f39207a943dadb8e22103032fd092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a unit vector, but keeps direction. Leans towards (1,0,0...) for nullvectors, costs more.  <a href="#a633f39207a943dadb8e22103032fd092">More...</a><br /></td></tr>
<tr class="separator:a633f39207a943dadb8e22103032fd092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19ec077dfee78710bc0b545a0be1443"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed&gt; </td></tr>
<tr class="memitem:ab19ec077dfee78710bc0b545a0be1443"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#ab19ec077dfee78710bc0b545a0be1443">SafeNormalize</a> (const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;v, const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;degenerate)</td></tr>
<tr class="memdesc:ab19ec077dfee78710bc0b545a0be1443"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a unit vector, but keeps direction. Leans towards <em>degenerate</em>  for nullvectors, costs more.  <a href="#ab19ec077dfee78710bc0b545a0be1443">More...</a><br /></td></tr>
<tr class="separator:ab19ec077dfee78710bc0b545a0be1443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ec8fc0998226692f3229dba9a7a9d8"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed&gt; </td></tr>
<tr class="memitem:a40ec8fc0998226692f3229dba9a7a9d8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a40ec8fc0998226692f3229dba9a7a9d8">Fill</a> (<a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;lhs, T all)</td></tr>
<tr class="memdesc:a40ec8fc0998226692f3229dba9a7a9d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all elements of the vector to the same value.  <a href="#a40ec8fc0998226692f3229dba9a7a9d8">More...</a><br /></td></tr>
<tr class="separator:a40ec8fc0998226692f3229dba9a7a9d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaccf0f2d637cd30ecf4370a01c06b1b"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed&gt; </td></tr>
<tr class="memitem:aeaccf0f2d637cd30ecf4370a01c06b1b"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#aeaccf0f2d637cd30ecf4370a01c06b1b">Dot</a> (const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;lhs, const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aeaccf0f2d637cd30ecf4370a01c06b1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the scalar product (dot product) of the two arguments.  <a href="#aeaccf0f2d637cd30ecf4370a01c06b1b">More...</a><br /></td></tr>
<tr class="separator:aeaccf0f2d637cd30ecf4370a01c06b1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee9fa97b67b159b9af598ceb914ae9b8"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed, class... Args&gt; </td></tr>
<tr class="memitem:aee9fa97b67b159b9af598ceb914ae9b8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#aee9fa97b67b159b9af598ceb914ae9b8">Cross</a> (const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;head, Args &amp;&amp;... args) -&gt; <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt;</td></tr>
<tr class="memdesc:aee9fa97b67b159b9af598ceb914ae9b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the generalized cross-product in N dimensions.  <a href="#aee9fa97b67b159b9af598ceb914ae9b8">More...</a><br /></td></tr>
<tr class="separator:aee9fa97b67b159b9af598ceb914ae9b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae12db1708b475d0ab3689c999e8b4a39"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed&gt; </td></tr>
<tr class="memitem:ae12db1708b475d0ab3689c999e8b4a39"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#ae12db1708b475d0ab3689c999e8b4a39">Cross</a> (const std::array&lt; const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; *, Dim - 1 &gt; &amp;args) -&gt; <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt;</td></tr>
<tr class="memdesc:ae12db1708b475d0ab3689c999e8b4a39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the generalized cross-product in N dimensions.  <a href="#ae12db1708b475d0ab3689c999e8b4a39">More...</a><br /></td></tr>
<tr class="separator:ae12db1708b475d0ab3689c999e8b4a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad76e097b8d3ebba6c19bab57cf7eacda"><td class="memTemplParams" colspan="2">template&lt;class T , bool Packed&gt; </td></tr>
<tr class="memitem:ad76e097b8d3ebba6c19bab57cf7eacda"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, 2, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#ad76e097b8d3ebba6c19bab57cf7eacda">Cross</a> (const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, 2, Packed &gt; &amp;arg)</td></tr>
<tr class="memdesc:ad76e097b8d3ebba6c19bab57cf7eacda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 2-dimensional cross prodct, which is a vector perpendicular to the argument.  <a href="#ad76e097b8d3ebba6c19bab57cf7eacda">More...</a><br /></td></tr>
<tr class="separator:ad76e097b8d3ebba6c19bab57cf7eacda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa74a76d0702d20ddcdad26b6a374db6b"><td class="memTemplParams" colspan="2">template&lt;class T , bool Packed&gt; </td></tr>
<tr class="memitem:aa74a76d0702d20ddcdad26b6a374db6b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, 2, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#aa74a76d0702d20ddcdad26b6a374db6b">Cross</a> (const std::array&lt; const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, 2, Packed &gt; *, 1 &gt; &amp;arg)</td></tr>
<tr class="memdesc:aa74a76d0702d20ddcdad26b6a374db6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 2-dimensional cross prodct, which is a vector perpendicular to the argument.  <a href="#aa74a76d0702d20ddcdad26b6a374db6b">More...</a><br /></td></tr>
<tr class="separator:aa74a76d0702d20ddcdad26b6a374db6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c3b42cda12106392747135f280e26e5"><td class="memTemplParams" colspan="2">template&lt;class T , bool Packed&gt; </td></tr>
<tr class="memitem:a8c3b42cda12106392747135f280e26e5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, 3, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a8c3b42cda12106392747135f280e26e5">Cross</a> (const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, 3, Packed &gt; &amp;lhs, const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, 3, Packed &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a8c3b42cda12106392747135f280e26e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 3-dimensional cross-product.  <a href="#a8c3b42cda12106392747135f280e26e5">More...</a><br /></td></tr>
<tr class="separator:a8c3b42cda12106392747135f280e26e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64895ea3919fa9dc4700db2804d1be87"><td class="memTemplParams" colspan="2">template&lt;class T , bool Packed&gt; </td></tr>
<tr class="memitem:a64895ea3919fa9dc4700db2804d1be87"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, 3, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a64895ea3919fa9dc4700db2804d1be87">Cross</a> (const std::array&lt; const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, 3, Packed &gt; *, 2 &gt; &amp;args)</td></tr>
<tr class="memdesc:a64895ea3919fa9dc4700db2804d1be87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 3-dimensional cross-product.  <a href="#a64895ea3919fa9dc4700db2804d1be87">More...</a><br /></td></tr>
<tr class="separator:a64895ea3919fa9dc4700db2804d1be87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043e02ce689fc4baabf6b03d70b4e3c3"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed&gt; </td></tr>
<tr class="memitem:a043e02ce689fc4baabf6b03d70b4e3c3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a043e02ce689fc4baabf6b03d70b4e3c3">Min</a> (const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;lhs, const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a043e02ce689fc4baabf6b03d70b4e3c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the element-wise minimum of arguments  <a href="#a043e02ce689fc4baabf6b03d70b4e3c3">More...</a><br /></td></tr>
<tr class="separator:a043e02ce689fc4baabf6b03d70b4e3c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf51b54cece8c83b507d6e75afa614bb"><td class="memTemplParams" colspan="2">template&lt;class T , int Dim, bool Packed&gt; </td></tr>
<tr class="memitem:abf51b54cece8c83b507d6e75afa614bb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemathter.html#abf51b54cece8c83b507d6e75afa614bb">Max</a> (const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;lhs, const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;rhs)</td></tr>
<tr class="memdesc:abf51b54cece8c83b507d6e75afa614bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the element-wise maximum of arguments  <a href="#abf51b54cece8c83b507d6e75afa614bb">More...</a><br /></td></tr>
<tr class="separator:abf51b54cece8c83b507d6e75afa614bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af952fc7afa3d3600ade4d2c868344352"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemathter.html#af952fc7afa3d3600ade4d2c868344352">false</a> () const</td></tr>
<tr class="separator:af952fc7afa3d3600ade4d2c868344352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22bd596866870bd3efc72306b6ac3430"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a22bd596866870bd3efc72306b6ac3430">true</a> () const</td></tr>
<tr class="separator:a22bd596866870bd3efc72306b6ac3430"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a1e962b1351b70ec69c38fb462754b6d5"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemathter.html#a1e962b1351b70ec69c38fb462754b6d5">DYNAMIC</a> = -1</td></tr>
<tr class="memdesc:a1e962b1351b70ec69c38fb462754b6d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify this as <a class="el" href="classmathter_1_1_vector.html" title="Represents a vector in N-dimensional space. ">Vector</a> or <a class="el" href="classmathter_1_1_matrix.html">Matrix</a> dimension template parameter to set size at runtime. PLEASE NOTE THAT DYNAMICALLY SIZED VECTORS AND MATRICES ARE NOT SUPPORTED YET.  <a href="#a1e962b1351b70ec69c38fb462754b6d5">More...</a><br /></td></tr>
<tr class="separator:a1e962b1351b70ec69c38fb462754b6d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a5229d739adb6492fcb269f0168b72724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5229d739adb6492fcb269f0168b72724">&#9670;&nbsp;</a></span>eEnclosingBracket</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemathter.html#a5229d739adb6492fcb269f0168b72724">mathter::eEnclosingBracket</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5229d739adb6492fcb269f0168b72724ab50339a10e1de285ac99d4c3990b8693"></a>NONE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a5229d739adb6492fcb269f0168b72724a8fa806846c4d483f565b6fe5218baf7f"></a>PARANTHESE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a5229d739adb6492fcb269f0168b72724a62c2198c66464d0dc1b231ef327c09fa"></a>BRACKET&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a5229d739adb6492fcb269f0168b72724aa978f79663129bdb1ab765185b15a9b2"></a>BRACE&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="aa43cfd54adea35fd8286213c5d198336"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa43cfd54adea35fd8286213c5d198336">&#9670;&nbsp;</a></span>eMatrixLayout</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemathter.html#aa43cfd54adea35fd8286213c5d198336">mathter::eMatrixLayout</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the memory layout of matrices. </p>
<p>For ROW_MAJOR layout, the matrix's first row comes first in memory, followed immediately by the second row's elements. For COLUMN_MAJOR matrices, the memory region begins with the first column. </p>
<p>This does not affect arithmetic or matrix generator function in any way. Your arithmetic will work the same way if you change this. </p>
<p>Please note that changing this flag may affect performance of arithmetic operations. Profile your code to determine optimal settings. Performance may depend on multiple factors. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa43cfd54adea35fd8286213c5d198336a21541962976d7709c26e9cd8385bd648"></a>ROW_MAJOR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa43cfd54adea35fd8286213c5d198336ada7520ed89bff27b02664af80951c6b0"></a>COLUMN_MAJOR&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a41e16685dc7a27ca3a59016e6cfcae32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41e16685dc7a27ca3a59016e6cfcae32">&#9670;&nbsp;</a></span>eMatrixOrder</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemathter.html#a41e16685dc7a27ca3a59016e6cfcae32">mathter::eMatrixOrder</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if you want to left- or right-multiply your matrices with vectors. </p>
<p>This flag affects the generated transformation matrices. If you want to write M2*M1*v in your code, then choose PRECEDE_VECTOR, if you want v*M1*M2, choose FOLLOW_VECTOR. Matrices generated by Transform, Scale, Rotation and similar functions will match your order of multiplication. (I.e. bottom row is translation if you choose FOLLOW_VECTOR). </p>
<p>You can still use M*v and v*M in your code. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a41e16685dc7a27ca3a59016e6cfcae32ae9c7f0ecfec845e853f09317db5857a3"></a>PRECEDE_VECTOR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a41e16685dc7a27ca3a59016e6cfcae32afa44321a5158c32f32558c8220df8353"></a>FOLLOW_VECTOR&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae676fff5afb56c796e476b7be04c7608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae676fff5afb56c796e476b7be04c7608">&#9670;&nbsp;</a></span>Abs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T mathter::Abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The euclidean length of the vector of the 4 elements of the quaternion. </p>

</div>
</div>
<a id="a3200e12d8fcb8d89f313a5423fbc7cde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3200e12d8fcb8d89f313a5423fbc7cde">&#9670;&nbsp;</a></span>AlmostEqual() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mathter::AlmostEqual </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>d1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>d2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::true_type&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a94a5d4c9078a598a4332e1b495a4462d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94a5d4c9078a598a4332e1b495a4462d">&#9670;&nbsp;</a></span>AlmostEqual() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mathter::AlmostEqual </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>d1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>d2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::false_type&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a764cda941d47ce80c03dbd3206fb06f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a764cda941d47ce80c03dbd3206fb06f2">&#9670;&nbsp;</a></span>AlmostEqual() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class  = std::enable_if_t&lt;traits::NotVector&lt;T&gt;::value &amp;&amp; traits::NotMatrix&lt;T&gt;::value &amp;&amp; traits::NotQuaternion&lt;T&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mathter::AlmostEqual </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>d1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>d2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3f5d009b9c66bffba003ab295e99b2d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f5d009b9c66bffba003ab295e99b2d9">&#9670;&nbsp;</a></span>AlmostEqual() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed1, bool Packed2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mathter::AlmostEqual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0b113df0133920dcc9f934665ab33c8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b113df0133920dcc9f934665ab33c8e">&#9670;&nbsp;</a></span>AlmostEqual() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool Packed1, bool Packed2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mathter::AlmostEqual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abab322d8bbe8dc58339d2087c6aecb2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abab322d8bbe8dc58339d2087c6aecb2b">&#9670;&nbsp;</a></span>AlmostEqual() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Rows, int Columns, eMatrixOrder Order1, eMatrixLayout Layout1, bool Packed1, eMatrixOrder Order2, eMatrixLayout Layout2, bool Packed2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mathter::AlmostEqual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order1, Layout1, Packed1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order2, Layout2, Packed2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad7933ea57d631adcb3df6562ad0bb1bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7933ea57d631adcb3df6562ad0bb1bc">&#9670;&nbsp;</a></span>ApproxVec()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LinalgClass &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmathter_1_1_approx_helper.html">ApproxHelper</a>&lt;LinalgClass&gt; mathter::ApproxVec </td>
          <td>(</td>
          <td class="paramtype">const LinalgClass &amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a72dba46a963b55a9931280baa47f797a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72dba46a963b55a9931280baa47f797a">&#9670;&nbsp;</a></span>Clamp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Scalar mathter::Clamp </td>
          <td>(</td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>lower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>upper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Limits arg to the range [lower, upper], making it either lower or upper if out of range. </p>

</div>
</div>
<a id="a7b0f6944099a5a9395f47f6a7d30c62b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b0f6944099a5a9395f47f6a7d30c62b">&#9670;&nbsp;</a></span>Clamp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; mathter::Clamp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>lower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>upper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clamps all elements of the vector according to the scalar clamp. </p>

</div>
</div>
<a id="a97e115a4eb960ba00446d63fb85e1e82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97e115a4eb960ba00446d63fb85e1e82">&#9670;&nbsp;</a></span>Conjugate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt;T, Packed&gt; mathter::Conjugate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Negates the imaginary values of the quaternion. </p>

</div>
</div>
<a id="aee9fa97b67b159b9af598ceb914ae9b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee9fa97b67b159b9af598ceb914ae9b8">&#9670;&nbsp;</a></span>Cross() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed, class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mathter::Cross </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;T, Dim, Packed&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the generalized cross-product in N dimensions. </p>
<p>You must supply N-1 arguments of type <a class="el" href="classmathter_1_1_vector.html" title="Represents a vector in N-dimensional space. ">Vector</a>&lt;N&gt;. The function returns the generalized cross product as defined by <a href="https://en.wikipedia.org/wiki/Cross_product#Multilinear_algebra">https://en.wikipedia.org/wiki/Cross_product#Multilinear_algebra</a>. </p>

</div>
</div>
<a id="ae12db1708b475d0ab3689c999e8b4a39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae12db1708b475d0ab3689c999e8b4a39">&#9670;&nbsp;</a></span>Cross() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mathter::Cross </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; *, Dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;T, Dim, Packed&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the generalized cross-product in N dimensions. </p>
<p>See <a href="https://en.wikipedia.org/wiki/Cross_product#Multilinear_algebra">https://en.wikipedia.org/wiki/Cross_product#Multilinear_algebra</a> for definition. </p>

</div>
</div>
<a id="ad76e097b8d3ebba6c19bab57cf7eacda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad76e097b8d3ebba6c19bab57cf7eacda">&#9670;&nbsp;</a></span>Cross() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;T, 2, Packed&gt; mathter::Cross </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, 2, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the 2-dimensional cross prodct, which is a vector perpendicular to the argument. </p>

</div>
</div>
<a id="aa74a76d0702d20ddcdad26b6a374db6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa74a76d0702d20ddcdad26b6a374db6b">&#9670;&nbsp;</a></span>Cross() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;T, 2, Packed&gt; mathter::Cross </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, 2, Packed &gt; *, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the 2-dimensional cross prodct, which is a vector perpendicular to the argument. </p>

</div>
</div>
<a id="a8c3b42cda12106392747135f280e26e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c3b42cda12106392747135f280e26e5">&#9670;&nbsp;</a></span>Cross() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;T, 3, Packed&gt; mathter::Cross </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, 3, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, 3, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the 3-dimensional cross-product. </p>

</div>
</div>
<a id="a64895ea3919fa9dc4700db2804d1be87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64895ea3919fa9dc4700db2804d1be87">&#9670;&nbsp;</a></span>Cross() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;T, 3, Packed&gt; mathter::Cross </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, 3, Packed &gt; *, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the 3-dimensional cross-product. </p>

</div>
</div>
<a id="a2110b681b7c68078f2f81ff186144d08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2110b681b7c68078f2f81ff186144d08">&#9670;&nbsp;</a></span>DecomposeLU()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, eMatrixOrder Order, eMatrixLayout Layout, bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mathter::DecomposeLU </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Dim, Dim, Order, Layout, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a505330b72294388c562989458aa7c512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a505330b72294388c562989458aa7c512">&#9670;&nbsp;</a></span>DecomposeLUP() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, eMatrixOrder Order, eMatrixLayout Layout, bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mathter::DecomposeLUP </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Dim, Dim, Order, Layout, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>parity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements LU decomposition with partial pivoting. </p>
<p>Handles singular matrices as well. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>Lower triangular matrix, LU=P'A. </td></tr>
    <tr><td class="paramname">U</td><td>Upper triangular matrix, LU=P'A. </td></tr>
    <tr><td class="paramname">P</td><td>Row permutations. LU=P'A, where P' is a matrix whose i-th row's P[i]-th element is one. </td></tr>
    <tr><td class="paramname">parity</td><td>The parity of the permutation described by P. Odd: 1, Even: -1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b93f1eecad5e31f23b17718c9371aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b93f1eecad5e31f23b17718c9371aaf">&#9670;&nbsp;</a></span>DecomposeLUP() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, eMatrixOrder Order, eMatrixLayout Layout, bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mathter::DecomposeLUP </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Dim, Dim, Order, Layout, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements LU decomposition with partial pivoting. </p>
<p>Handles singular matrices as well. </p>

</div>
</div>
<a id="a4aaa3f8329d7f3894a0ac6aad7b89924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aaa3f8329d7f3894a0ac6aad7b89924">&#9670;&nbsp;</a></span>DecomposeQR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Rows, int Columns, eMatrixOrder Order, eMatrixLayout Layout, bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mathter::DecomposeQR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order, Layout, Packed &gt;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the QR decomposition of the matrix using Householder transforms. </p>
<p>The matrix must have Rows &lt;= Columns. It's a full QR decomposition, not a thin one. </p>

</div>
</div>
<a id="aeada4b17cb1272d8b3090c600053970c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeada4b17cb1272d8b3090c600053970c">&#9670;&nbsp;</a></span>DecomposeSVD()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Rows, int Columns, eMatrixOrder Order, eMatrixLayout Layout, bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mathter::DecomposeSVD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order, Layout, Packed &gt;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the thin SVD of the matrix. </p>
<p>For wide matrices, V is wide while U and S square. For tall matrices, U is tall while S and V square. </p>

</div>
</div>
<a id="a0f3d3eb6c6f391c1e3ce1dafe84bf2a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f3d3eb6c6f391c1e3ce1dafe84bf2a7">&#9670;&nbsp;</a></span>Deg2Rad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mathter::Deg2Rad </td>
          <td>(</td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>deg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts degrees to radians. </p>

</div>
</div>
<a id="ade013562d383964232eaa66339cf91be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade013562d383964232eaa66339cf91be">&#9670;&nbsp;</a></span>Determinant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, eMatrixOrder Order, eMatrixLayout Layout, bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T mathter::Determinant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Dim, Dim, Order, Layout, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the determinant of the matrix. </p>

</div>
</div>
<a id="a556b6ef96f335976bbc04a8f93eee5a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a556b6ef96f335976bbc04a8f93eee5a1">&#9670;&nbsp;</a></span>Distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U , int Dim, bool Packed1, bool Packed2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mathter::Distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; U, Dim, Packed2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the euclidean distance between to vectors. </p>

</div>
</div>
<a id="a1c9775a2294478c2ed45d42ac3c977ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c9775a2294478c2ed45d42ac3c977ba">&#9670;&nbsp;</a></span>DivElementwise() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class T2 , int Rows, int Columns, eMatrixOrder Order, eMatrixOrder Order2, eMatrixLayout Layout, bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mathter::DivElementwise </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order, Layout, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T2, Rows, Columns, Order2, Layout, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac37f97dbaaebc376820be97e3cdd77bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac37f97dbaaebc376820be97e3cdd77bc">&#9670;&nbsp;</a></span>DivElementwise() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class T2 , int Rows, int Columns, eMatrixOrder Order, eMatrixOrder Order2, eMatrixLayout Layout, bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mathter::DivElementwise </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order, Layout, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T2, Rows, Columns, Order2, <a class="el" href="classmathter_1_1traits_1_1_opposite_layout.html">traits::OppositeLayout</a>&lt; Layout &gt;::value, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeaccf0f2d637cd30ecf4370a01c06b1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaccf0f2d637cd30ecf4370a01c06b1b">&#9670;&nbsp;</a></span>Dot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T mathter::Dot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the scalar product (dot product) of the two arguments. </p>

</div>
</div>
<a id="a93311c17c3a640e5730b9a9815e0c511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93311c17c3a640e5730b9a9815e0c511">&#9670;&nbsp;</a></span>Exp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt;T, Packed&gt; mathter::Exp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Natural quaternion exponentiation, base e. </p>

</div>
</div>
<a id="af952fc7afa3d3600ade4d2c868344352"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af952fc7afa3d3600ade4d2c868344352">&#9670;&nbsp;</a></span>false()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mathter::false </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a40ec8fc0998226692f3229dba9a7a9d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40ec8fc0998226692f3229dba9a7a9d8">&#9670;&nbsp;</a></span>Fill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mathter::Fill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>all</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets all elements of the vector to the same value. </p>

</div>
</div>
<a id="af5f4425b0e0e1c5b87b7b89395b753f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5f4425b0e0e1c5b87b7b89395b753f5">&#9670;&nbsp;</a></span>Identity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto mathter::Identity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an identity matrix or identity quaternion. </p>
<p>If the matrix is not square, it will look like a truncated larger square identity matrix. </p>

</div>
</div>
<a id="afeb8316e14b5e73578e2a16913bb1ca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeb8316e14b5e73578e2a16913bb1ca5">&#9670;&nbsp;</a></span>Intersect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mathter::Intersect </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac58867fce293c7e6a24e8383802e8c7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac58867fce293c7e6a24e8383802e8c7d">&#9670;&nbsp;</a></span>Inverse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, eMatrixOrder Order, eMatrixLayout Layout, bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt;T, Dim, Dim, Order, Layout, Packed&gt; mathter::Inverse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Dim, Dim, Order, Layout, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the inverse of the matrix. </p>

</div>
</div>
<a id="aa32d6739219a5c7711fbd87b259f8449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa32d6739219a5c7711fbd87b259f8449">&#9670;&nbsp;</a></span>Inverse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt;T, Packed&gt; mathter::Inverse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the quaternion of opposite rotation. </p>

</div>
</div>
<a id="abeab38015d970ee421f4c2a88284a1d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeab38015d970ee421f4c2a88284a1d1">&#9670;&nbsp;</a></span>IsNormalized() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mathter::IsNormalized </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the vector is unit vector. There's some tolerance due to floating points. </p>

</div>
</div>
<a id="a8063857014319059b0420565a4c17c29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8063857014319059b0420565a4c17c29">&#9670;&nbsp;</a></span>IsNormalized() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mathter::IsNormalized </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the quaternion is a unit quaternion, with some tolerance for floats. </p>

</div>
</div>
<a id="a4535d355930f4386e0f389207e0aa8a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4535d355930f4386e0f389207e0aa8a3">&#9670;&nbsp;</a></span>IsNullvector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mathter::IsNullvector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the vector's length is too small for precise calculations (i.e. normalization). </p>
<p>"Too small" means smaller than the square root of the smallest number representable by the underlying scalar. This value is ~10^-18 for floats and ~10^-154 for doubles. </p>

</div>
</div>
<a id="a2da1838ffbfb7116d5bead5eb2442bf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2da1838ffbfb7116d5bead5eb2442bf0">&#9670;&nbsp;</a></span>IsRotationMatrix3D()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Rows, int Columns, eMatrixOrder Order, eMatrixLayout Layout, bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mathter::IsRotationMatrix3D </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order, Layout, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if the matrix is a proper rotation matrix. </p>
<p>Proper rotation matrices are orthogonal and have a determinant of +1. </p>

</div>
</div>
<a id="a7e4484e9bfcc0f406aa7dea4e95e6b7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e4484e9bfcc0f406aa7dea4e95e6b7a">&#9670;&nbsp;</a></span>Length() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T mathter::Length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the length of the vector. </p>

</div>
</div>
<a id="a2df7aaeca5a2cbb0461817066f19942c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2df7aaeca5a2cbb0461817066f19942c">&#9670;&nbsp;</a></span>Length() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T mathter::Length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the absolute value of the quaternion. </p>
<p>Just like complex numbers, it's the length of the vector formed by the coefficients. </p>

</div>
</div>
<a id="a6319585c3b16a6d70b0bbd3ab44814df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6319585c3b16a6d70b0bbd3ab44814df">&#9670;&nbsp;</a></span>LengthPrecise()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T mathter::LengthPrecise </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the length of the vector, avoids overflow and underflow, so it's more expensive. </p>

</div>
</div>
<a id="acdbed2d415b612e7eb8e4ad4a5de4128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdbed2d415b612e7eb8e4ad4a5de4128">&#9670;&nbsp;</a></span>LengthSquared() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T mathter::LengthSquared </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the squared length of the vector. </p>

</div>
</div>
<a id="a9a267ea5fb35c48ba3b24eb61709b4cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a267ea5fb35c48ba3b24eb61709b4cb">&#9670;&nbsp;</a></span>LengthSquared() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T mathter::LengthSquared </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the square of the absolute value. </p>
<p>Just like complex numbers, it's the square of the length of the vector formed by the coefficients. This is much faster than <a class="el" href="namespacemathter.html#a2df7aaeca5a2cbb0461817066f19942c">. </a> </p>

</div>
</div>
<a id="a9ca92ae75a9b13765cc4964c22ed087b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ca92ae75a9b13765cc4964c22ed087b">&#9670;&nbsp;</a></span>Log()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt;T, Packed&gt; mathter::Log </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Natural quaternion logarithm, base e. </p>

</div>
</div>
<a id="a4ef09737154728355cbea9e8a7d78a7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ef09737154728355cbea9e8a7d78a7d">&#9670;&nbsp;</a></span>LookAt() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed, size_t BaseDim, size_t FlipDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mathter::LookAt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>eye</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt;, BaseDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>bases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; bool, FlipDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>flipAxes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a camera look-at matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eye</td><td>The camera's position. </td></tr>
    <tr><td class="paramname">target</td><td>The camera's target. </td></tr>
    <tr><td class="paramname">bases</td><td>Basis vectors fixing the camera's orientation. </td></tr>
    <tr><td class="paramname">flipAxis</td><td>Set any element to true to flip an axis in camera space. </td></tr>
  </table>
  </dd>
</dl>
<p>The camera look down the vector going from <em>eye</em>  to <em>target</em> , but it can still rotate around that vector. To fix the rotation, an "up" vector must be provided in 3 dimensions. In higher dimensions, we need multiple up vectors. Unfortunately I can't fucking remember how these basis vectors are used, but they are orthogonalized to each-other and to the look vector. I can't remember the order of orthogonalization. </p>

</div>
</div>
<a id="a069e282382f9fb674f7b44f35d7b1eb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a069e282382f9fb674f7b44f35d7b1eb9">&#9670;&nbsp;</a></span>LookAt() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mathter::LookAt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, 2, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>eye</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, 2, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>positiveYForward</em> = <code><a class="el" href="namespacemathter.html#a22bd596866870bd3efc72306b6ac3430">true</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flipX</em> = <code><a class="el" href="namespacemathter.html#af952fc7afa3d3600ade4d2c868344352">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a 2D look-at matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eye</td><td>The camera's position. </td></tr>
    <tr><td class="paramname">target</td><td>The camera's target. </td></tr>
    <tr><td class="paramname">positiveYForward</td><td>True if the camera looks towards +Y, false if -Y. </td></tr>
    <tr><td class="paramname">flipX</td><td>True to flip X in camera space. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0853b75e7db69334f04371a190fd36ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0853b75e7db69334f04371a190fd36ba">&#9670;&nbsp;</a></span>LookAt() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mathter::LookAt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, 3, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>eye</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, 3, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, 3, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>up</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>positiveZForward</em> = <code><a class="el" href="namespacemathter.html#a22bd596866870bd3efc72306b6ac3430">true</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flipX</em> = <code><a class="el" href="namespacemathter.html#af952fc7afa3d3600ade4d2c868344352">false</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flipY</em> = <code><a class="el" href="namespacemathter.html#af952fc7afa3d3600ade4d2c868344352">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a 3D look-at matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eye</td><td>The camera's position. </td></tr>
    <tr><td class="paramname">target</td><td>The camera's target. </td></tr>
    <tr><td class="paramname">up</td><td>Up direction in world space. </td></tr>
    <tr><td class="paramname">positiveZForward</td><td>True if the camera looks towards +Z, false if -Z. </td></tr>
    <tr><td class="paramname">flipX</td><td>True to flip X in camera space. </td></tr>
    <tr><td class="paramname">flipY</td><td>True to flip Y in camera space. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abf51b54cece8c83b507d6e75afa614bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf51b54cece8c83b507d6e75afa614bb">&#9670;&nbsp;</a></span>Max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;T, Dim, Packed&gt; mathter::Max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the element-wise maximum of arguments </p>

</div>
</div>
<a id="a043e02ce689fc4baabf6b03d70b4e3c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a043e02ce689fc4baabf6b03d70b4e3c3">&#9670;&nbsp;</a></span>Min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;T, Dim, Packed&gt; mathter::Min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the element-wise minimum of arguments </p>

</div>
</div>
<a id="a2b5091b070bbebe24fd568ab6836e712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b5091b070bbebe24fd568ab6836e712">&#9670;&nbsp;</a></span>MulElementwise() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class T2 , int Rows, int Columns, eMatrixOrder Order, eMatrixOrder Order2, eMatrixLayout Layout, bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mathter::MulElementwise </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order, Layout, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T2, Rows, Columns, Order2, Layout, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a704247409f83a99c1ed738cb3742c0bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a704247409f83a99c1ed738cb3742c0bb">&#9670;&nbsp;</a></span>MulElementwise() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class T2 , int Rows, int Columns, eMatrixOrder Order, eMatrixOrder Order2, eMatrixLayout Layout, bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mathter::MulElementwise </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order, Layout, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T2, Rows, Columns, Order2, <a class="el" href="classmathter_1_1traits_1_1_opposite_layout.html">traits::OppositeLayout</a>&lt; Layout &gt;::value, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae615e37db0d75b776b7ead89a72b532c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae615e37db0d75b776b7ead89a72b532c">&#9670;&nbsp;</a></span>MultiplyAdd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;T, Dim, Packed&gt; mathter::MultiplyAdd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return (a*b)+c. Performs MAD or FMA if supported by target architecture. </p>

</div>
</div>
<a id="a139e1f15e50dcc982c17906832e7cd6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a139e1f15e50dcc982c17906832e7cd6b">&#9670;&nbsp;</a></span>Norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Rows, int Columns, eMatrixOrder Order, eMatrixLayout Layout, bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T mathter::Norm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order, Layout, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the Frobenius norm of the matrix. </p>

</div>
</div>
<a id="af6343e463fffcecd32ec6336859226a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6343e463fffcecd32ec6336859226a1">&#9670;&nbsp;</a></span>Normalize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;T, Dim, Packed&gt; mathter::Normalize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a unit vector, but keeps direction. </p>

</div>
</div>
<a id="afd54869eab6bf47134e0c94100e12a12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd54869eab6bf47134e0c94100e12a12">&#9670;&nbsp;</a></span>Normalize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt;T, Packed&gt; mathter::Normalize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the unit quaternion of the same direction. Does not change this object. </p>

</div>
</div>
<a id="a0f5608905538ebefa7d5fafdc20826a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f5608905538ebefa7d5fafdc20826a0">&#9670;&nbsp;</a></span>NormSquared()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Rows, int Columns, eMatrixOrder Order, eMatrixLayout Layout, bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T mathter::NormSquared </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order, Layout, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the square of the Frobenius norm of the matrix. </p>

</div>
</div>
<a id="a8af196535873baeabcba0467a55ffc8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8af196535873baeabcba0467a55ffc8e">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mathter::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check exact unequality of coefficients. </p>

</div>
</div>
<a id="a1cfc7bee93e028f1e39589b4b634b075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cfc7bee93e028f1e39589b4b634b075">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int Rows, int Columns, class T1 , class T2 , eMatrixOrder Order1, eMatrixOrder Order2, eMatrixLayout Layout1, eMatrixLayout Layout2, bool Packed1, bool Packed2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mathter::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T1, Rows, Columns, Order1, Layout1, Packed1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T2, Rows, Columns, Order2, Layout2, Packed2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a93a659331c8864c15fcd1f0676026ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93a659331c8864c15fcd1f0676026ded">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mathter::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exactly compares two vectors. </p>
<p>&lt;The usual warning about floating point numbers&gt; </p>

</div>
</div>
<a id="ae27f4e5caf5f1f7b0e8f95b27cdc81a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae27f4e5caf5f1f7b0e8f95b27cdc81a1">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;T, Dim, Packed&gt; mathter::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Elementwise (Hadamard) vector product. </p>

</div>
</div>
<a id="a76463c85cdf0a7ccdec59007ea0cad1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76463c85cdf0a7ccdec59007ea0cad1a">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool QPacked, bool PackedA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;T, 3, PackedA&gt; mathter::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, QPacked &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, 3, PackedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotates (and scales) vector by quaternion. </p>

</div>
</div>
<a id="aa6d103838eaf3bf01e93840e32a9c4fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6d103838eaf3bf01e93840e32a9c4fa">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool QPacked, bool PackedA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;T, 3, PackedA&gt; mathter::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, 3, PackedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, QPacked &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotates (and scales) vector by quaternion. </p>

</div>
</div>
<a id="af9cf6b563c14f18ff2c5f6c941630374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9cf6b563c14f18ff2c5f6c941630374">&#9670;&nbsp;</a></span>operator*() <span class="overload">[4/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vt , class Mt , int Vd, int Mcol, eMatrixOrder Morder, bool Packed, class Rt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;Rt, Mcol, Packed&gt; mathter::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; Vt, Vd, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; Mt, Vd, Mcol, Morder, <a class="el" href="namespacemathter.html#aa43cfd54adea35fd8286213c5d198336a21541962976d7709c26e9cd8385bd648">eMatrixLayout::ROW_MAJOR</a>, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4c1d88a03fd648114ca44cf865286792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c1d88a03fd648114ca44cf865286792">&#9670;&nbsp;</a></span>operator*() <span class="overload">[5/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vt , class Mt , int Vd, int Mcol, eMatrixOrder Morder, bool Packed, class Rt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;Rt, Mcol, Packed&gt; mathter::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; Vt, Vd, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; Mt, Vd, Mcol, Morder, <a class="el" href="namespacemathter.html#aa43cfd54adea35fd8286213c5d198336ada7520ed89bff27b02664af80951c6b0">eMatrixLayout::COLUMN_MAJOR</a>, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7029f205897464ccef7b3d9f2809c518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7029f205897464ccef7b3d9f2809c518">&#9670;&nbsp;</a></span>operator*() <span class="overload">[6/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vt , class Mt , int Vd, int Mcol, eMatrixOrder Morder, eMatrixLayout Mlayout, bool Packed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;<a class="el" href="namespacemathter_1_1traits.html#a859c47fdf245eb5d7313ea9cf4f1c071">traits::MatMulElemT</a>&lt;Vt, Mt&gt;, Mcol, Packed&gt; mathter::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; Vt, Vd, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; Mt, Vd, Mcol, Morder, Mlayout, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2b2b7dcd7569a845fac513bd24f05900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b2b7dcd7569a845fac513bd24f05900">&#9670;&nbsp;</a></span>operator*() <span class="overload">[7/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vt , class Mt , int Vd, eMatrixLayout Mlayout, eMatrixOrder Morder, bool Packed, class Rt  = traits::MatMulElemT&lt;Vt, Mt&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;Rt, Vd, Packed&gt; mathter::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; Vt, Vd, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; Mt, Vd+1, Vd, Morder, Mlayout, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8dfdb11fa3a6f03eb424182d7d098154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dfdb11fa3a6f03eb424182d7d098154">&#9670;&nbsp;</a></span>operator*() <span class="overload">[8/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U , int Rows1, int Match, int Columns2, eMatrixOrder Order1, eMatrixOrder Order2, bool Packed, class V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto mathter::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows1, Match, Order1, <a class="el" href="namespacemathter.html#aa43cfd54adea35fd8286213c5d198336a21541962976d7709c26e9cd8385bd648">eMatrixLayout::ROW_MAJOR</a>, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; U, Match, Columns2, Order2, <a class="el" href="namespacemathter.html#aa43cfd54adea35fd8286213c5d198336a21541962976d7709c26e9cd8385bd648">eMatrixLayout::ROW_MAJOR</a>, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt;V, Rows1, Columns2, Order1, <a class="el" href="namespacemathter.html#aa43cfd54adea35fd8286213c5d198336a21541962976d7709c26e9cd8385bd648">eMatrixLayout::ROW_MAJOR</a>, Packed&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad01624f8752fb86e2f336e88d1b32323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad01624f8752fb86e2f336e88d1b32323">&#9670;&nbsp;</a></span>operator*() <span class="overload">[9/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vt , class Mt , int Vd, eMatrixLayout Mlayout, eMatrixOrder Morder, bool Packed, class Rt  = traits::MatMulElemT&lt;Vt, Mt&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;Rt, Vd, Packed&gt; mathter::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; Vt, Vd, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; Mt, Vd+1, Vd+1, Morder, Mlayout, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2f18e5fba716e84d59dc99c2431dee70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f18e5fba716e84d59dc99c2431dee70">&#9670;&nbsp;</a></span>operator*() <span class="overload">[10/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vt , class Mt , int Vd, int Mrow, eMatrixOrder Morder, bool Packed, class Rt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;Rt, Mrow, Packed&gt; mathter::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; Mt, Mrow, Vd, Morder, <a class="el" href="namespacemathter.html#aa43cfd54adea35fd8286213c5d198336a21541962976d7709c26e9cd8385bd648">eMatrixLayout::ROW_MAJOR</a>, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; Vt, Vd, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1cc58f6b6189a97325c37730f0928159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cc58f6b6189a97325c37730f0928159">&#9670;&nbsp;</a></span>operator*() <span class="overload">[11/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vt , class Mt , int Vd, int Mrow, eMatrixOrder Morder, bool Packed, class Rt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;Rt, Mrow, Packed&gt; mathter::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; Mt, Mrow, Vd, Morder, <a class="el" href="namespacemathter.html#aa43cfd54adea35fd8286213c5d198336ada7520ed89bff27b02664af80951c6b0">eMatrixLayout::COLUMN_MAJOR</a>, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; Vt, Vd, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a22d28fda3927adef04acb19d6c147d26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22d28fda3927adef04acb19d6c147d26">&#9670;&nbsp;</a></span>operator*() <span class="overload">[12/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U , int Rows1, int Match, int Columns2, eMatrixOrder Order1, eMatrixOrder Order2, bool Packed, class V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto mathter::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows1, Match, Order1, <a class="el" href="namespacemathter.html#aa43cfd54adea35fd8286213c5d198336a21541962976d7709c26e9cd8385bd648">eMatrixLayout::ROW_MAJOR</a>, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; U, Match, Columns2, Order2, <a class="el" href="namespacemathter.html#aa43cfd54adea35fd8286213c5d198336ada7520ed89bff27b02664af80951c6b0">eMatrixLayout::COLUMN_MAJOR</a>, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt;V, Rows1, Columns2, Order1, <a class="el" href="namespacemathter.html#aa43cfd54adea35fd8286213c5d198336a21541962976d7709c26e9cd8385bd648">eMatrixLayout::ROW_MAJOR</a>, Packed&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b6232ccc675fdd581afc6240663cfa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b6232ccc675fdd581afc6240663cfa7">&#9670;&nbsp;</a></span>operator*() <span class="overload">[13/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt;T, Packed&gt; mathter::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d0c4c785dd28bba5c0ce69b4f072e3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d0c4c785dd28bba5c0ce69b4f072e3c">&#9670;&nbsp;</a></span>operator*() <span class="overload">[14/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vt , class Mt , int Vd, int Mrow, eMatrixOrder Morder, eMatrixLayout Mlayout, bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;<a class="el" href="namespacemathter_1_1traits.html#a859c47fdf245eb5d7313ea9cf4f1c071">traits::MatMulElemT</a>&lt;Vt, Mt&gt;, Mrow, Packed&gt; mathter::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; Mt, Mrow, Vd, Morder, Mlayout, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; Vt, Vd, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3a149b08eafef328af95e3da82fd9c6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a149b08eafef328af95e3da82fd9c6f">&#9670;&nbsp;</a></span>operator*() <span class="overload">[15/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt;T, Packed&gt; mathter::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a255d68cc40cc8e780f1264e43fdf9135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a255d68cc40cc8e780f1264e43fdf9135">&#9670;&nbsp;</a></span>operator*() <span class="overload">[16/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U , int Rows1, int Match, int Columns2, eMatrixOrder Order1, eMatrixOrder Order2, bool Packed, class V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto mathter::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows1, Match, Order1, <a class="el" href="namespacemathter.html#aa43cfd54adea35fd8286213c5d198336ada7520ed89bff27b02664af80951c6b0">eMatrixLayout::COLUMN_MAJOR</a>, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; U, Match, Columns2, Order2, <a class="el" href="namespacemathter.html#aa43cfd54adea35fd8286213c5d198336ada7520ed89bff27b02664af80951c6b0">eMatrixLayout::COLUMN_MAJOR</a>, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt;V, Rows1, Columns2, Order1, <a class="el" href="namespacemathter.html#aa43cfd54adea35fd8286213c5d198336ada7520ed89bff27b02664af80951c6b0">eMatrixLayout::COLUMN_MAJOR</a>, Packed&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7df3d1a68f83e4308b710bb3aee7a8ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7df3d1a68f83e4308b710bb3aee7a8ff">&#9670;&nbsp;</a></span>operator*() <span class="overload">[17/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vt , class Mt , int Vd, eMatrixLayout Mlayout, eMatrixOrder Morder, bool Packed, class Rt  = traits::MatMulElemT&lt;Vt, Mt&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;Rt, Vd, Packed&gt; mathter::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; Mt, Vd, Vd+1, Morder, Mlayout, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; Vt, Vd, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a78a7a8f5346901d6179e16b0029704ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78a7a8f5346901d6179e16b0029704ea">&#9670;&nbsp;</a></span>operator*() <span class="overload">[18/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vt , class Mt , int Vd, eMatrixLayout Mlayout, eMatrixOrder Morder, bool Packed, class Rt  = traits::MatMulElemT&lt;Vt, Mt&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;Rt, Vd, Packed&gt; mathter::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; Mt, Vd+1, Vd+1, Morder, Mlayout, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; Vt, Vd, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa1afc380149f6caac62a26d64b12273b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1afc380149f6caac62a26d64b12273b">&#9670;&nbsp;</a></span>operator*() <span class="overload">[19/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool Packed, class U , class  = typename std::enable_if&lt;!std::is_same&lt;U, Quaternion&lt;T, Packed&gt;&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt;T, Packed&gt; mathter::operator* </td>
          <td>(</td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies all coefficients of the quaternion by <em>s</em> . </p>

</div>
</div>
<a id="a7c5f9b26dea991066a12be89497fad1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c5f9b26dea991066a12be89497fad1d">&#9670;&nbsp;</a></span>operator*() <span class="overload">[20/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U , int Rows1, int Match, int Columns2, eMatrixOrder Order1, eMatrixOrder Order2, bool Packed, class V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto mathter::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows1, Match, Order1, <a class="el" href="namespacemathter.html#aa43cfd54adea35fd8286213c5d198336ada7520ed89bff27b02664af80951c6b0">eMatrixLayout::COLUMN_MAJOR</a>, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; U, Match, Columns2, Order2, <a class="el" href="namespacemathter.html#aa43cfd54adea35fd8286213c5d198336a21541962976d7709c26e9cd8385bd648">eMatrixLayout::ROW_MAJOR</a>, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt;V, Rows1, Columns2, Order1, <a class="el" href="namespacemathter.html#aa43cfd54adea35fd8286213c5d198336ada7520ed89bff27b02664af80951c6b0">eMatrixLayout::COLUMN_MAJOR</a>, Packed&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1463e21d3d76a468ad1930f7d8bf7412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1463e21d3d76a468ad1930f7d8bf7412">&#9670;&nbsp;</a></span>operator*() <span class="overload">[21/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 , int Rows1, int Match, int Columns2, eMatrixOrder Order1, eMatrixOrder Order2, eMatrixLayout Layout1, eMatrixLayout Layout2, bool PackedA&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto mathter::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T1, Rows1, Match, Order1, Layout1, PackedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T2, Match, Columns2, Order2, Layout2, PackedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt;<a class="el" href="namespacemathter_1_1traits.html#a859c47fdf245eb5d7313ea9cf4f1c071">traits::MatMulElemT</a>&lt;T1, T2&gt;, Rows1, Columns2, Order1, Layout1, PackedA&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab909c21a9a8ee10650a07058dc640206"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab909c21a9a8ee10650a07058dc640206">&#9670;&nbsp;</a></span>operator*() <span class="overload">[22/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;T, Dim, Packed&gt; mathter::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scales the vector by <em>rhs</em> . </p>

</div>
</div>
<a id="a8f27811e5f6cb8bb12f0042f07a67283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f27811e5f6cb8bb12f0042f07a67283">&#9670;&nbsp;</a></span>operator*() <span class="overload">[23/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed, class U , class  = typename std::enable_if&lt;std::is_convertible&lt;U, T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;T, Dim, Packed&gt; mathter::operator* </td>
          <td>(</td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scales vector by <em>lhs</em> . </p>

</div>
</div>
<a id="a89c6a7301562f98494eb6c3139a59d5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89c6a7301562f98494eb6c3139a59d5f">&#9670;&nbsp;</a></span>operator*() <span class="overload">[24/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed, int... Indices&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;Dim == sizeof...(Indices), <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;T, Dim, Packed&gt; &gt; mathter::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_swizzle.html">Swizzle</a>&lt; T, Indices... &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad76cd5d70a7924367f49161355bd17b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad76cd5d70a7924367f49161355bd17b8">&#9670;&nbsp;</a></span>operator*() <span class="overload">[25/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed, int... Indices&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;Dim == sizeof...(Indices), <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;T, Dim, Packed&gt; &gt; mathter::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_swizzle.html">Swizzle</a>&lt; T, Indices... &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab01b8d3364ce00bee75bf988ecc50569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab01b8d3364ce00bee75bf988ecc50569">&#9670;&nbsp;</a></span>operator*() <span class="overload">[26/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Rows, int Columns, eMatrixOrder Order, eMatrixLayout Layout, bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt;T, Rows, Columns, Order, Layout, Packed&gt; mathter::operator* </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order, Layout, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9ebf763d2b38787b8cd25ff1ca51fae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ebf763d2b38787b8cd25ff1ca51fae3">&#9670;&nbsp;</a></span>operator*() <span class="overload">[27/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Rows, int Columns, eMatrixOrder Order, eMatrixLayout Layout, bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt;T, Rows, Columns, Order, Layout, Packed&gt; mathter::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order, Layout, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1e4eda500a5f9130865cd40a88517fa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e4eda500a5f9130865cd40a88517fa1">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool QPacked, bool PackedA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;T, 3, PackedA&gt;&amp; mathter::operator*= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, 3, PackedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, QPacked &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotates (and scales) vector by quaternion. </p>

</div>
</div>
<a id="af943c9e61314c8a64d967755f5db2d91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af943c9e61314c8a64d967755f5db2d91">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;T, Dim, Packed&gt;&amp; mathter::operator*= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Elementwise (Hadamard) vector product. </p>

</div>
</div>
<a id="a6ac88918d571d04cac40bfd8b335bb34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ac88918d571d04cac40bfd8b335bb34">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt;T, Packed&gt;&amp; mathter::operator*= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a91ba8f46b00061ea189520eb21da66a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91ba8f46b00061ea189520eb21da66a1">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt;T, Packed&gt;&amp; mathter::operator*= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9c9396bcb5b8f3a4045413e66ca24137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c9396bcb5b8f3a4045413e66ca24137">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;T, Dim, Packed&gt;&amp; mathter::operator*= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scales the vector by <em>rhs</em> . </p>

</div>
</div>
<a id="ac3ced1b5e3c395ebdcdbf86ca2d2f20a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3ced1b5e3c395ebdcdbf86ca2d2f20a">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vt , class Mt , int Vd, eMatrixOrder Morder, eMatrixLayout Layout, bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;Vt, Vd, Packed&gt;&amp; mathter::operator*= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; Vt, Vd, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; Mt, Vd, Vd, Morder, Layout, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8259997b1f5c5c79f98f31beba486307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8259997b1f5c5c79f98f31beba486307">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 , int Dim, eMatrixOrder Order1, eMatrixOrder Order2, eMatrixLayout Layout1, eMatrixLayout Layout2, bool Packed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt;T1, Dim, Dim, Order1, Layout1, Packed&gt;&amp; mathter::operator*= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T1, Dim, Dim, Order1, Layout1, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T2, Dim, Dim, Order2, Layout2, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a50493de58b06709a0c20e3ffbb53f331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50493de58b06709a0c20e3ffbb53f331">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed, int... Indices&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;Dim == sizeof...(Indices), <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;T, Dim, Packed&gt; &gt;&amp; mathter::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_swizzle.html">Swizzle</a>&lt; T, Indices... &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af8a455d71dce14efaeb8719c1892c703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8a455d71dce14efaeb8719c1892c703">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Rows, int Columns, eMatrixOrder Order, eMatrixLayout Layout, bool Packed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt;T, Rows, Columns, Order, Layout, Packed&gt;&amp; mathter::operator*= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order, Layout, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies all elements of the matrix by scalar. </p>

</div>
</div>
<a id="a8ee542fc0f48ea6211c1df5c6862beb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ee542fc0f48ea6211c1df5c6862beb2">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;T, Dim, Packed&gt; mathter::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Elementwise vector addition. </p>

</div>
</div>
<a id="a140882fe6701f061e3cdb616ee8820b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a140882fe6701f061e3cdb616ee8820b1">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt;T, Packed&gt; mathter::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7186d91a61ea4f0170144b1cebe35d21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7186d91a61ea4f0170144b1cebe35d21">&#9670;&nbsp;</a></span>operator+() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt;T, Packed&gt; mathter::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aff4214a57ff4ef0a23997254b08588cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff4214a57ff4ef0a23997254b08588cb">&#9670;&nbsp;</a></span>operator+() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool Packed, class U , class  = typename std::enable_if&lt;!traits::IsQuaternion&lt;U&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt;T, Packed&gt; mathter::operator+ </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a real to the real part of the quaternion. </p>

</div>
</div>
<a id="a555ffa28c9358dccaefa2519c35343ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a555ffa28c9358dccaefa2519c35343ed">&#9670;&nbsp;</a></span>operator+() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;T, Dim, Packed&gt; mathter::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds <em>rhs</em>  to each element of the vector. </p>

</div>
</div>
<a id="a8a89f7b9fd22087f33c47d59e96ab9ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a89f7b9fd22087f33c47d59e96ab9ce">&#9670;&nbsp;</a></span>operator+() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U , int Rows, int Columns, eMatrixOrder Order1, eMatrixOrder Order2, eMatrixLayout SameLayout, bool Packed, class V  = decltype(T() + U())&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt;U, Rows, Columns, Order1, SameLayout, Packed&gt; mathter::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order1, SameLayout, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; U, Rows, Columns, Order2, SameLayout, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa72e6a390e648aca26ad185ce57e9bca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa72e6a390e648aca26ad185ce57e9bca">&#9670;&nbsp;</a></span>operator+() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed, class U , class  = typename std::enable_if&lt;std::is_convertible&lt;U, T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;T, Dim, Packed&gt; mathter::operator+ </td>
          <td>(</td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds <em>lhs</em>  to all elements of the vector. </p>

</div>
</div>
<a id="a310dde6da1864848cde57eb67760d85c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a310dde6da1864848cde57eb67760d85c">&#9670;&nbsp;</a></span>operator+() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;T, Dim, Packed&gt; mathter::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Optional plus sign, leaves the vector as is. </p>

</div>
</div>
<a id="a1e02f95e30162f06b260143a06576b93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e02f95e30162f06b260143a06576b93">&#9670;&nbsp;</a></span>operator+() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U , int Rows, int Columns, eMatrixOrder Order1, eMatrixOrder Order2, eMatrixLayout Layout1, eMatrixLayout Layout2, bool Packed, class V , class  = typename std::enable_if&lt;Layout1 != Layout2&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt;U, Rows, Columns, Order1, Layout1, Packed&gt; mathter::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order1, Layout1, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; U, Rows, Columns, Order2, Layout2, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3e418fdd4164a02162ed1c0970db91ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e418fdd4164a02162ed1c0970db91ea">&#9670;&nbsp;</a></span>operator+() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed, int... Indices&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;Dim == sizeof...(Indices), <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;T, Dim, Packed&gt; &gt; mathter::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_swizzle.html">Swizzle</a>&lt; T, Indices... &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab0144ef90450f567ae0b5a4f5354b879"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0144ef90450f567ae0b5a4f5354b879">&#9670;&nbsp;</a></span>operator+() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed, int... Indices&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;Dim == sizeof...(Indices), <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;T, Dim, Packed&gt; &gt; mathter::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_swizzle.html">Swizzle</a>&lt; T, Indices... &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac50982566194d1bbfbebf3b5af798552"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac50982566194d1bbfbebf3b5af798552">&#9670;&nbsp;</a></span>operator+() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class T , int Rows, int Columns, eMatrixOrder Order, eMatrixLayout Layout, bool Packed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt;T, Rows, Columns, Order, Layout, Packed&gt; mathter::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order, Layout, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2b2787f569da1a60d47f27163e78d7c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b2787f569da1a60d47f27163e78d7c7">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt;T, Packed&gt;&amp; mathter::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2942ded99e880fae0ac9d43bca05c72b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2942ded99e880fae0ac9d43bca05c72b">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;T, Dim, Packed&gt;&amp; mathter::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Elementwise vector addition. </p>

</div>
</div>
<a id="a83276761b0ee3f542f2fe5928c4d7464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83276761b0ee3f542f2fe5928c4d7464">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;T, Dim, Packed&gt;&amp; mathter::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds <em>rhs</em>  to each element of the vector. </p>

</div>
</div>
<a id="a1545a4d34838e071ce79d4e003f79dcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1545a4d34838e071ce79d4e003f79dcb">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U , int Rows, int Columns, eMatrixOrder Order1, eMatrixOrder Order2, eMatrixLayout Layout1, eMatrixLayout Layout2, bool Packed, class V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt;U, Rows, Columns, Order1, Layout1, Packed&gt;&amp; mathter::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order1, Layout1, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; U, Rows, Columns, Order2, Layout2, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs matrix addition and stores result in this. </p>

</div>
</div>
<a id="a7626db67fb5d31ed57f8c3c99bb5afca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7626db67fb5d31ed57f8c3c99bb5afca">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed, int... Indices&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;Dim == sizeof...(Indices), <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;T, Dim, Packed&gt; &gt;&amp; mathter::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_swizzle.html">Swizzle</a>&lt; T, Indices... &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac44a2a08922a0d27b872bab73ac74e3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac44a2a08922a0d27b872bab73ac74e3b">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;T, Dim, Packed&gt; mathter::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Elementwise vector subtraction. </p>

</div>
</div>
<a id="aec2084d2097d2cd28c640624cae053b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec2084d2097d2cd28c640624cae053b8">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt;T, Packed&gt; mathter::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab9e642a408702d0d148cf434ce8f5ed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9e642a408702d0d148cf434ce8f5ed4">&#9670;&nbsp;</a></span>operator-() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt;T, Packed&gt; mathter::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0b82d45d19daecaa159de246f2363b6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b82d45d19daecaa159de246f2363b6e">&#9670;&nbsp;</a></span>operator-() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;T, Dim, Packed&gt; mathter::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts <em>rhs</em>  from each element of the vector. </p>

</div>
</div>
<a id="acbd62ab69cfe32cf2d5859208bfb061e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbd62ab69cfe32cf2d5859208bfb061e">&#9670;&nbsp;</a></span>operator-() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed, class U , class  = typename std::enable_if&lt;std::is_convertible&lt;U, T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;T, Dim, Packed&gt; mathter::operator- </td>
          <td>(</td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a vector with <em>lhs</em>  as all elements, then subtracts <em>rhs</em>  from it. </p>

</div>
</div>
<a id="a4083f119a7550afa4e3237bb50c384f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4083f119a7550afa4e3237bb50c384f6">&#9670;&nbsp;</a></span>operator-() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U , int Rows, int Columns, eMatrixOrder Order1, eMatrixOrder Order2, eMatrixLayout SameLayout, bool Packed, class V  = decltype(T() - U())&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt;U, Rows, Columns, Order1, SameLayout, Packed&gt; mathter::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order1, SameLayout, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; U, Rows, Columns, Order2, SameLayout, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a812bd5de504beb601ecbf016ab7a7ef7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a812bd5de504beb601ecbf016ab7a7ef7">&#9670;&nbsp;</a></span>operator-() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;T, Dim, Packed&gt; mathter::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Negates all elements of the vector. </p>

</div>
</div>
<a id="ae5b5d81c9c2433e8bec4d9b370400119"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5b5d81c9c2433e8bec4d9b370400119">&#9670;&nbsp;</a></span>operator-() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U , int Rows, int Columns, eMatrixOrder Order1, eMatrixOrder Order2, eMatrixLayout Layout1, eMatrixLayout Layout2, bool Packed, class V , class  = typename std::enable_if&lt;Layout1 != Layout2&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt;U, Rows, Columns, Order1, Layout1, Packed&gt; mathter::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order1, Layout1, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; U, Rows, Columns, Order2, Layout2, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac47819028b6efe4b59e7e393c8e0d148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac47819028b6efe4b59e7e393c8e0d148">&#9670;&nbsp;</a></span>operator-() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed, int... Indices&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;Dim == sizeof...(Indices), <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;T, Dim, Packed&gt; &gt; mathter::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_swizzle.html">Swizzle</a>&lt; T, Indices... &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6de36293ddab4f9e5016978eda3ec7e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6de36293ddab4f9e5016978eda3ec7e9">&#9670;&nbsp;</a></span>operator-() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed, int... Indices&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;Dim == sizeof...(Indices), <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;T, Dim, Packed&gt; &gt; mathter::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_swizzle.html">Swizzle</a>&lt; T, Indices... &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ade5b600117256aeda7aaf1894fc09b99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade5b600117256aeda7aaf1894fc09b99">&#9670;&nbsp;</a></span>operator-() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class T , int Rows, int Columns, eMatrixOrder Order, eMatrixLayout Layout, bool Packed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt;T, Rows, Columns, Order, Layout, Packed&gt; mathter::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order, Layout, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a13904d0192606fb6fb982dcf78d474fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13904d0192606fb6fb982dcf78d474fc">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt;T, Packed&gt;&amp; mathter::operator-= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac4fe0e48ee495e2e209fbe68837a556f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4fe0e48ee495e2e209fbe68837a556f">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;T, Dim, Packed&gt;&amp; mathter::operator-= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Elementwise vector subtraction. </p>

</div>
</div>
<a id="a8d7e64be6f5ab2ab1782341b33933060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d7e64be6f5ab2ab1782341b33933060">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;T, Dim, Packed&gt;&amp; mathter::operator-= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts <em>rhs</em>  from each element of the vector. </p>

</div>
</div>
<a id="a02467cad892a559b4183c6a9f61fa5f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02467cad892a559b4183c6a9f61fa5f5">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U , int Rows, int Columns, eMatrixOrder Order1, eMatrixOrder Order2, eMatrixLayout Layout1, eMatrixLayout Layout2, bool Packed, class V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt;U, Rows, Columns, Order1, Layout1, Packed&gt;&amp; mathter::operator-= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order1, Layout1, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; U, Rows, Columns, Order2, Layout2, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs matrix subtraction and stores result in this. </p>

</div>
</div>
<a id="ab70a4e1bd5b3f0a73421383ad4f63f1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab70a4e1bd5b3f0a73421383ad4f63f1d">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed, int... Indices&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;Dim == sizeof...(Indices), <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;T, Dim, Packed&gt; &gt;&amp; mathter::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_swizzle.html">Swizzle</a>&lt; T, Indices... &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acba1f61dcdd8f6c4f7ee1005cacb5c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acba1f61dcdd8f6c4f7ee1005cacb5c4b">&#9670;&nbsp;</a></span>operator/() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;T, Dim, Packed&gt; mathter::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Elementwise vector division. </p>

</div>
</div>
<a id="a1504e2c2afc7d8f2fe85fcbe292cb578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1504e2c2afc7d8f2fe85fcbe292cb578">&#9670;&nbsp;</a></span>operator/() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt;T, Packed&gt; mathter::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a39081aa028277f443efd1f77f0311bd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39081aa028277f443efd1f77f0311bd8">&#9670;&nbsp;</a></span>operator/() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool Packed, class U , class  = typename std::enable_if&lt;!std::is_same&lt;U, Quaternion&lt;T, Packed&gt;&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt;T, Packed&gt; mathter::operator/ </td>
          <td>(</td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divides all coefficients of the quaternion by <em>s</em> . </p>

</div>
</div>
<a id="a90b27e7c826d6293621189f0b0878d0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90b27e7c826d6293621189f0b0878d0e">&#9670;&nbsp;</a></span>operator/() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;T, Dim, Packed&gt; mathter::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scales the vector by 1/<em>rhs</em> . </p>

</div>
</div>
<a id="aab1b715f156a9375f8c6a59ab9f1e18c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab1b715f156a9375f8c6a59ab9f1e18c">&#9670;&nbsp;</a></span>operator/() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed, class U , class  = typename std::enable_if&lt;std::is_convertible&lt;U, T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;T, Dim, Packed&gt; mathter::operator/ </td>
          <td>(</td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a vector with <em>lhs</em>  as all elements, then divides it by <em>rhs</em> . </p>

</div>
</div>
<a id="a5397fb937f96f1abaee2023fbb1c73e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5397fb937f96f1abaee2023fbb1c73e6">&#9670;&nbsp;</a></span>operator/() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed, int... Indices&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;Dim == sizeof...(Indices), <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;T, Dim, Packed&gt; &gt; mathter::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_swizzle.html">Swizzle</a>&lt; T, Indices... &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1d45d68f369a47163eb4bdd2ee9cd17d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d45d68f369a47163eb4bdd2ee9cd17d">&#9670;&nbsp;</a></span>operator/() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed, int... Indices&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;Dim == sizeof...(Indices), <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;T, Dim, Packed&gt; &gt; mathter::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_swizzle.html">Swizzle</a>&lt; T, Indices... &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1bb99d0f900a2acdcdfd5f0579b2af80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bb99d0f900a2acdcdfd5f0579b2af80">&#9670;&nbsp;</a></span>operator/() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Rows, int Columns, eMatrixOrder Order, eMatrixLayout Layout, bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt;T, Rows, Columns, Order, Layout, Packed&gt; mathter::operator/ </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order, Layout, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a43c3eecacec100b8f050d67a3ee71fb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43c3eecacec100b8f050d67a3ee71fb9">&#9670;&nbsp;</a></span>operator/() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Rows, int Columns, eMatrixOrder Order, eMatrixLayout Layout, bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt;T, Rows, Columns, Order, Layout, Packed&gt; mathter::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order, Layout, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6fe8d6c35cacd5561c61e19cd7ebd414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fe8d6c35cacd5561c61e19cd7ebd414">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;T, Dim, Packed&gt;&amp; mathter::operator/= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Elementwise vector division. </p>

</div>
</div>
<a id="ac0e65a21406262127da06a0ad333e2a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e65a21406262127da06a0ad333e2a0">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt;T, Packed&gt;&amp; mathter::operator/= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8065ea26fc434fd242bbec48ecb915aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8065ea26fc434fd242bbec48ecb915aa">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;T, Dim, Packed&gt;&amp; mathter::operator/= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scales the vector by 1/<em>rhs</em> . </p>

</div>
</div>
<a id="a23d6c20aae639976958fbd56779d0737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23d6c20aae639976958fbd56779d0737">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed, int... Indices&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;Dim == sizeof...(Indices), <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;T, Dim, Packed&gt; &gt;&amp; mathter::operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_swizzle.html">Swizzle</a>&lt; T, Indices... &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a15873b3ca92b2656885879c133865756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15873b3ca92b2656885879c133865756">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Rows, int Columns, eMatrixOrder Order, eMatrixLayout Layout, bool Packed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt;T, Rows, Columns, Order, Layout, Packed&gt;&amp; mathter::operator/= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order, Layout, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divides all elements of the matrix by scalar. </p>

</div>
</div>
<a id="a1ded50017eca8f308cbb7726449282d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ded50017eca8f308cbb7726449282d6">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; mathter::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">mathter::Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the vector like [1,2,3]. </p>

</div>
</div>
<a id="a5b55f15ae8b41bf84889fc12f098b153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b55f15ae8b41bf84889fc12f098b153">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LinalgClass &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; mathter::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmathter_1_1_approx_helper.html">ApproxHelper</a>&lt; LinalgClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afd74e9ce5289459089204ef8d24481ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd74e9ce5289459089204ef8d24481ab">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Rows, int Columns, eMatrixOrder Order, eMatrixLayout Layout, bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; mathter::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order, Layout, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a27a598d7c634aca7a712e667f0906df3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27a598d7c634aca7a712e667f0906df3">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; mathter::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad1a46fa6467ff9454b11422445a01f3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1a46fa6467ff9454b11422445a01f3d">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int Rows, int Columns, class T1 , class T2 , eMatrixOrder Order1, eMatrixOrder Order2, eMatrixLayout Layout1, eMatrixLayout Layout2, bool Packed1, bool Packed2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mathter::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T1, Rows, Columns, Order1, Layout1, Packed1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T2, Rows, Columns, Order2, Layout2, Packed2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a986fe6c4bffc6dcf1145a4ead56b0a7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a986fe6c4bffc6dcf1145a4ead56b0a7b">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mathter::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check exact equality of coefficients. </p>

</div>
</div>
<a id="addf4d4417129f113c9787759a5400f36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addf4d4417129f113c9787759a5400f36">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mathter::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exactly compares two vectors. </p>
<p>&lt;The usual warning about floating point numbers&gt; </p>

</div>
</div>
<a id="a90dd6a8246292c7a7199e84a1df53490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90dd6a8246292c7a7199e84a1df53490">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LinalgClass1 , class LinalgClass2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mathter::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmathter_1_1_approx_helper.html">ApproxHelper</a>&lt; LinalgClass1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LinalgClass2 &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0cfcfc45f17be0679376e299482de97d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cfcfc45f17be0679376e299482de97d">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LinalgClass1 , class LinalgClass2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mathter::operator== </td>
          <td>(</td>
          <td class="paramtype">const LinalgClass1 &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmathter_1_1_approx_helper.html">ApproxHelper</a>&lt; LinalgClass2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afbfd31d11f6e189ea855ca487c4b93f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbfd31d11f6e189ea855ca487c4b93f2">&#9670;&nbsp;</a></span>operator==() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LinalgClass1 , class LinalgClass2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mathter::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmathter_1_1_approx_helper.html">ApproxHelper</a>&lt; LinalgClass1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmathter_1_1_approx_helper.html">ApproxHelper</a>&lt; LinalgClass2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a058a01e46b51c3ad1982ec703f700395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a058a01e46b51c3ad1982ec703f700395">&#9670;&nbsp;</a></span>operator|() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed, class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_vector.html">mathter::Vector</a>&lt;T, Dim + 1, Packed&gt; mathter::operator| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">mathter::Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenates the arguments, and returns the concatenated vector. </p>

</div>
</div>
<a id="a2a0dd583fe8092ee4b40d0f4dfabd07d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a0dd583fe8092ee4b40d0f4dfabd07d">&#9670;&nbsp;</a></span>operator|() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , int Dim1, class T2 , int Dim2, bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_vector.html">mathter::Vector</a>&lt;T1, Dim1 + Dim2, Packed&gt; mathter::operator| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">mathter::Vector</a>&lt; T1, Dim1, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">mathter::Vector</a>&lt; T2, Dim2, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenates the arguments, and returns the concatenated vector. </p>

</div>
</div>
<a id="a4f2a61053048268cab43b6cc49854d22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f2a61053048268cab43b6cc49854d22">&#9670;&nbsp;</a></span>operator|() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed, class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_vector.html">mathter::Vector</a>&lt;T, Dim + 1, Packed&gt; mathter::operator| </td>
          <td>(</td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">mathter::Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenates the arguments, and returns the concatenated vector. </p>

</div>
</div>
<a id="ab554eacfac281c6e6f71abd26859785e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab554eacfac281c6e6f71abd26859785e">&#9670;&nbsp;</a></span>operator|() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , int... Indices1, class T2 , int... Indices2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;T1, sizeof...(Indices2) + sizeof...(Indices2), <a class="el" href="namespacemathter.html#af952fc7afa3d3600ade4d2c868344352">false</a>&gt; mathter::operator| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_swizzle.html">Swizzle</a>&lt; T1, Indices1... &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_swizzle.html">Swizzle</a>&lt; T2, Indices2... &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenates the arguments, and returns the concatenated vector. </p>

</div>
</div>
<a id="a93c07d44bdaa19730c8f644af773eddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93c07d44bdaa19730c8f644af773eddc">&#9670;&nbsp;</a></span>operator|() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , int... Indices1, class T2 , int Dim, bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;T1, sizeof...(Indices1) + Dim, Packed&gt; mathter::operator| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_swizzle.html">Swizzle</a>&lt; T1, Indices1... &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T2, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenates the arguments, and returns the concatenated vector. </p>

</div>
</div>
<a id="ae2836c40fabc9a09ea543d912d0d323d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2836c40fabc9a09ea543d912d0d323d">&#9670;&nbsp;</a></span>operator|() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , int... Indices1, class T2 , int Dim, bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;T1, sizeof...(Indices1) + Dim, Packed&gt; mathter::operator| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T2, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_swizzle.html">Swizzle</a>&lt; T1, Indices1... &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenates the arguments, and returns the concatenated vector. </p>

</div>
</div>
<a id="ad69e1d654153673b5fe705b4758a6089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad69e1d654153673b5fe705b4758a6089">&#9670;&nbsp;</a></span>operator|() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , int... Indices1, class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;T1, sizeof...(Indices1) + 1, <a class="el" href="namespacemathter.html#af952fc7afa3d3600ade4d2c868344352">false</a>&gt; mathter::operator| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_swizzle.html">Swizzle</a>&lt; T1, Indices1... &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenates the arguments, and returns the concatenated vector. </p>

</div>
</div>
<a id="a90e884298d7c1dce0c22431883a90e1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90e884298d7c1dce0c22431883a90e1a">&#9670;&nbsp;</a></span>operator|() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , int... Indices1, class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;T1, sizeof...(Indices1) + 1, <a class="el" href="namespacemathter.html#af952fc7afa3d3600ade4d2c868344352">false</a>&gt; mathter::operator| </td>
          <td>(</td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_swizzle.html">Swizzle</a>&lt; T1, Indices1... &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenates the arguments, and returns the concatenated vector. </p>

</div>
</div>
<a id="a34cefefbfde338f47d9c3cf30b0f9121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34cefefbfde338f47d9c3cf30b0f9121">&#9670;&nbsp;</a></span>Orthographic()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mathter::Orthographic </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>minBounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>maxBounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>projNearPlane</em> = <code>T(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>projFarPlane</em> = <code>T(1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an orthographics projection matrix. The volume before projection is an axis-aligned hypercube and it is projected onto a unit hypercube. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minBounds</td><td>The "left" corner of the hypercube. </td></tr>
    <tr><td class="paramname">maxBounds</td><td>The "right" corner of the hypercube. </td></tr>
    <tr><td class="paramname">projNearPlane</td><td>The lower bound of the last axis of the projected volume (Z axis in 3D). </td></tr>
    <tr><td class="paramname">projFarPlane</td><td>The upper bound of the last axis of the projected volume (Z axis in 3D). </td></tr>
  </table>
  </dd>
</dl>
<p>After projection, all axes range from -1 to 1, except for the last axis, which is specified explicitly. </p>

</div>
</div>
<a id="ab3697d4bcd477416233ae75a804183d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3697d4bcd477416233ae75a804183d6">&#9670;&nbsp;</a></span>Perspective() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int DimMinus1, bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mathter::Perspective </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>fovX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, DimMinus1, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>ratios</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>nearPlane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>farPlane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>projNearPlane</em> = <code>T(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>projFarPlane</em> = <code>T(1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a perspective projection matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fovX</td><td>Field of view on the first axis (usually denoted X) in radians. </td></tr>
    <tr><td class="paramname">ratios</td><td>Aspect ratio (or ratios in higher dimensions). FovX/FovY. </td></tr>
    <tr><td class="paramname">nearPlane</td><td>Near bound of the projected volume on the last axis (Z in 3D). </td></tr>
    <tr><td class="paramname">farPlane</td><td>Far bound of the projected volume on the last axis (Z in 3D). </td></tr>
    <tr><td class="paramname">projNearPlane</td><td>The near plane is taken here after projection. </td></tr>
    <tr><td class="paramname">projFarPlane</td><td>The far plane is taken here after projection. </td></tr>
  </table>
  </dd>
</dl>
<p>Post-projection near and far planes can be inverted. Negative ratios invert image. </p>

</div>
</div>
<a id="a3b40cde8d2444be45a860db88c5aafe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b40cde8d2444be45a860db88c5aafe7">&#9670;&nbsp;</a></span>Perspective() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mathter::Perspective </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>fov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>nearPlane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>farPlane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>projNearPlane</em> = <code>T(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>projFarPlane</em> = <code>T(1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a 2D projection matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fov</td><td>Field of view. </td></tr>
    <tr><td class="paramname">nearPlane</td><td>Lower bound of the volume on the Y axis. </td></tr>
    <tr><td class="paramname">farPlane</td><td>Upper bound of the volume on the Y axis. </td></tr>
    <tr><td class="paramname">projNearPlane</td><td>Near plane is taken here after projection. </td></tr>
    <tr><td class="paramname">projFarPlane</td><td>Far plane is taken here after projection. </td></tr>
  </table>
  </dd>
</dl>
<p>Post-projection bounds may be inverted. </p>

</div>
</div>
<a id="a27b419d8527c72af06969250fcb7d9a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27b419d8527c72af06969250fcb7d9a4">&#9670;&nbsp;</a></span>Perspective() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mathter::Perspective </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>fov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>aspectRatio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>nearPlane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>farPlane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>projNearPlane</em> = <code>T(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>projFarPlane</em> = <code>T(1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a 3D projection matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fov</td><td>Field of view. </td></tr>
    <tr><td class="paramname">aspectRatio</td><td>FovX/FovY, so 1.777 for a 16:9 screen. </td></tr>
    <tr><td class="paramname">nearPlane</td><td>Lower bound of the volume on the Y axis. </td></tr>
    <tr><td class="paramname">farPlane</td><td>Upper bound of the volume on the Y axis. </td></tr>
    <tr><td class="paramname">projNearPlane</td><td>Near plane is taken here after projection. </td></tr>
    <tr><td class="paramname">projFarPlane</td><td>Far plane is taken here after projection. </td></tr>
  </table>
  </dd>
</dl>
<p>Post-projection bounds may be inverted. </p>

</div>
</div>
<a id="af10142132fc984b872c1813f4379a68c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af10142132fc984b872c1813f4379a68c">&#9670;&nbsp;</a></span>Pow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt;T, Packed&gt; mathter::Pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_quaternion.html">Quaternion</a>&lt; T, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Raises <em>q</em>  to the power of <em>a</em> . </p>

</div>
</div>
<a id="af88ed58209428aadaa2b1f20fd3c7e4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af88ed58209428aadaa2b1f20fd3c7e4b">&#9670;&nbsp;</a></span>Rad2Deg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mathter::Rad2Deg </td>
          <td>(</td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>rad</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts radians to degrees. </p>

</div>
</div>
<a id="a10bdf5eec755e23047fe581e2700ff54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10bdf5eec755e23047fe581e2700ff54">&#9670;&nbsp;</a></span>Range() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_range_helper.html">RangeHelper</a>&lt;T&gt; mathter::Range </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7422073314358964a7b6456b6dbe2235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7422073314358964a7b6456b6dbe2235">&#9670;&nbsp;</a></span>Range() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_range_helper.html">RangeHelper</a>&lt;T&gt; mathter::Range </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af63bb811d15167408e7d288ca586ee65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af63bb811d15167408e7d288ca586ee65">&#9670;&nbsp;</a></span>Range() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_range_helper.html">RangeHelper</a>&lt;T&gt; mathter::Range </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>last</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a97d1c36c125b7aea126c8fb657143791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97d1c36c125b7aea126c8fb657143791">&#9670;&nbsp;</a></span>Rotation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mathter::Rotation </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>angle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a 2D rotation matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angle</td><td>Counter-clockwise angle in radians. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad52def7749c5eec45874d788b5b093c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad52def7749c5eec45874d788b5b093c5">&#9670;&nbsp;</a></span>RotationAxis() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mathter::RotationAxis </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotates around coordinate axis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">axis</td><td>0 for X, 1 for Y, 2 for Z and so on... </td></tr>
    <tr><td class="paramname">angle</td><td>Angle of rotation in radians. </td></tr>
  </table>
  </dd>
</dl>
<p>Positive angles rotate according to the right-hand rule in right-handed coordinate systems (left-handed likewise). </p>

</div>
</div>
<a id="a24d79040271c24c63d4b114bf087680b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24d79040271c24c63d4b114bf087680b">&#9670;&nbsp;</a></span>RotationAxis() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int Axis, class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mathter::RotationAxis </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>angle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotates around coordinate axis. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Axis</td><td>0 for X, 1 for Y, 2 for Z and so on... </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angle</td><td>Angle of rotation in radians. </td></tr>
  </table>
  </dd>
</dl>
<p>Positive angles rotate according to the right-hand rule in right-handed coordinate systems (left-handed likewise). </p>

</div>
</div>
<a id="a38dbd4e89c2f9631676f368c3732a975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38dbd4e89c2f9631676f368c3732a975">&#9670;&nbsp;</a></span>RotationAxis3()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int FirstAxis, int SecondAxis, int ThirdAxis, class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mathter::RotationAxis3 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>angle0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>angle1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>angle2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotates around three axes in succession. </p>
<p>Axes: 0 for X, 1 for Y and 2 for Z. Angles in radians. </p>

</div>
</div>
<a id="aff83202cf503ebf88db420cddbddc59e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff83202cf503ebf88db420cddbddc59e">&#9670;&nbsp;</a></span>RotationAxisAngle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool Vpacked, class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mathter::RotationAxisAngle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, 3, Vpacked &gt; &amp;&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>angle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotates around an arbitrary axis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">axis</td><td>Axis of rotation, must be normalized. </td></tr>
    <tr><td class="paramname">angle</td><td>Angle of rotation in radians. </td></tr>
  </table>
  </dd>
</dl>
<p>Right-hand (left-hand) rule is followed in right-handed (left-handed) systems. </p>

</div>
</div>
<a id="ae90205436e808c5e64fe6e7873740215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae90205436e808c5e64fe6e7873740215">&#9670;&nbsp;</a></span>RotationEuler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mathter::RotationEuler </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>z1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>z3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotation matrix from Euler angles. Rotations are Z-X-Z. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z1</td><td>Angle of the first rotation around Z in radians. </td></tr>
    <tr><td class="paramname">x2</td><td>Angle of the second rotation around X in radians. </td></tr>
    <tr><td class="paramname">z3</td><td>Angle of the third rotation around Z in radians. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a33a7333869dd8e51003ee8b6dd043e82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33a7333869dd8e51003ee8b6dd043e82">&#9670;&nbsp;</a></span>RotationRPY()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mathter::RotationRPY </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>y2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>z3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotation matrix from roll-pitch-yaw angles. Rotations are X-Y-Z. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z1</td><td>Angle of the first rotation around X in radians. </td></tr>
    <tr><td class="paramname">x2</td><td>Angle of the second rotation around Y in radians. </td></tr>
    <tr><td class="paramname">z3</td><td>Angle of the third rotation around Z in radians. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83679fe823ebea3274dc70d69098eaa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83679fe823ebea3274dc70d69098eaa7">&#9670;&nbsp;</a></span>RotationX()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mathter::RotationX </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>angle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotates around the X axis according to the right (left) hand rule. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angle</td><td>Angle of rotation in radians. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a913a805426dab0a8272bf8abd43bffd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a913a805426dab0a8272bf8abd43bffd1">&#9670;&nbsp;</a></span>RotationY()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mathter::RotationY </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>angle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotates around the Y axis according to the right (left) hand rule. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angle</td><td>Angle of rotation in radians. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38bc8b68c120b23410ccb50d46670ddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38bc8b68c120b23410ccb50d46670ddd">&#9670;&nbsp;</a></span>RotationZ()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mathter::RotationZ </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>angle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotates around the Z axis according to the right (left) hand rule. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angle</td><td>Angle of rotation in radians. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a633f39207a943dadb8e22103032fd092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a633f39207a943dadb8e22103032fd092">&#9670;&nbsp;</a></span>SafeNormalize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;T, Dim, Packed&gt; mathter::SafeNormalize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a unit vector, but keeps direction. Leans towards (1,0,0...) for nullvectors, costs more. </p>

</div>
</div>
<a id="ab19ec077dfee78710bc0b545a0be1443"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab19ec077dfee78710bc0b545a0be1443">&#9670;&nbsp;</a></span>SafeNormalize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;T, Dim, Packed&gt; mathter::SafeNormalize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>degenerate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a unit vector, but keeps direction. Leans towards <em>degenerate</em>  for nullvectors, costs more. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">degenerate</td><td>Must be a unit vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0afd4bab2379fc2d4098b2f928b96b5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0afd4bab2379fc2d4098b2f928b96b5a">&#9670;&nbsp;</a></span>Saturate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Scalar mathter::Saturate </td>
          <td>(</td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clamps argument into range [0,1]. </p>

</div>
</div>
<a id="a806c90f50a336e7040dcc2d5037bebf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a806c90f50a336e7040dcc2d5037bebf3">&#9670;&nbsp;</a></span>Saturate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; mathter::Saturate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clamps all elements into range [0,1]. </p>

</div>
</div>
<a id="a7d5e2b17284d01f055851818d97499f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d5e2b17284d01f055851818d97499f6">&#9670;&nbsp;</a></span>Scale() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vt , int Vdim, bool Vpacked&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mathter::Scale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; Vt, Vdim, Vpacked &gt; &amp;&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a scaling matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>A vector containing the scales of respective axes. The vector's dimension must be less than or equal to the matrix dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a718ef64e5a81c34e042fcfe9a9e4f84c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a718ef64e5a81c34e042fcfe9a9e4f84c">&#9670;&nbsp;</a></span>Scale() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Args, typename std::enable_if&lt;(traits::All&lt; traits::IsScalar, typename std::decay&lt; Args &gt;::type... &gt;::value), int &gt;::type  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mathter::Scale </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>scales</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a scaling matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scales</td><td>A list of scalars corresponding to scaling on respective axes. The number of arguments must be less than or equal to the matrix dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b6ed2a66d7a1971dbf86231f48fdbfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b6ed2a66d7a1971dbf86231f48fdbfe">&#9670;&nbsp;</a></span>Shear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mathter::Shear </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>slope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>principalAxis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>modulatorAxis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a shear matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slope</td><td>Strength of the shear. </td></tr>
    <tr><td class="paramname">principalAxis</td><td>Points are moved along this axis. </td></tr>
    <tr><td class="paramname">modulatorAxis</td><td>The displacement of points is proportional to this coordinate's value. </td></tr>
  </table>
  </dd>
</dl>
<p>The formula for displacement along the pricipal axis is <em>slope</em> pos[<em>modulatorAxis</em> ]. </p>

</div>
</div>
<a id="a574048a2c54d675e0f8d724628c1ec79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a574048a2c54d675e0f8d724628c1ec79">&#9670;&nbsp;</a></span>strtomat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Rows, int Columns, eMatrixOrder Order, eMatrixLayout Layout, bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt;T, Rows, Columns, Order, Layout, Packed&gt; mathter::strtomat </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8495cd6c02536d010b8cf749f430e43b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8495cd6c02536d010b8cf749f430e43b">&#9670;&nbsp;</a></span>strtomat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MatrixT mathter::strtomat </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac5ca63078146085de2a6a3ec97ed7521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5ca63078146085de2a6a3ec97ed7521">&#9670;&nbsp;</a></span>strtovec() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt;T, Dim, Packed&gt; mathter::strtovec </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a vector from a string. </p>

</div>
</div>
<a id="aeafceb87e09af648b2cb2837e0415f06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeafceb87e09af648b2cb2837e0415f06">&#9670;&nbsp;</a></span>strtovec() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VectorT mathter::strtovec </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a996e71fba0ff213b062c218adc51fac2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a996e71fba0ff213b062c218adc51fac2">&#9670;&nbsp;</a></span>Trace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, eMatrixOrder Order, eMatrixLayout Layout, bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T mathter::Trace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Dim, Dim, Order, Layout, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the trace (sum of diagonal elements) of the matrix. </p>

</div>
</div>
<a id="a4659304be5ecc5ec8cc11bea89de4409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4659304be5ecc5ec8cc11bea89de4409">&#9670;&nbsp;</a></span>Translation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Dim, bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mathter::Translation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_vector.html">Vector</a>&lt; T, Dim, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>translation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a translation matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">translation</td><td>The movement vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a674e0de9d767bc09f9749d558faf0575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a674e0de9d767bc09f9749d558faf0575">&#9670;&nbsp;</a></span>Translation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Args, typename std::enable_if&lt;(traits::All&lt; traits::IsScalar, typename std::decay&lt; Args &gt;::type... &gt;::value), int &gt;::type  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mathter::Translation </td>
          <td>(</td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>coordinates</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a translation matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coordinates</td><td>A list of scalars that specify movement along repsective axes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8539b36ef4095668525d638c0ca74e4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8539b36ef4095668525d638c0ca74e4b">&#9670;&nbsp;</a></span>Transpose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int Rows, int Columns, eMatrixOrder Order, eMatrixLayout Layout, bool Packed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt;T, Columns, Rows, Order, Layout, Packed&gt; mathter::Transpose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmathter_1_1_matrix.html">Matrix</a>&lt; T, Rows, Columns, Order, Layout, Packed &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transposes the matrix in-place. </p>

</div>
</div>
<a id="a22bd596866870bd3efc72306b6ac3430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22bd596866870bd3efc72306b6ac3430">&#9670;&nbsp;</a></span>true()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mathter::true </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a596d124112904deeaf2837665ea61244"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a596d124112904deeaf2837665ea61244">&#9670;&nbsp;</a></span>Zero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto mathter::Zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a matrix with all elements zero. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a1e962b1351b70ec69c38fb462754b6d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e962b1351b70ec69c38fb462754b6d5">&#9670;&nbsp;</a></span>DYNAMIC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int mathter::DYNAMIC = -1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify this as <a class="el" href="classmathter_1_1_vector.html" title="Represents a vector in N-dimensional space. ">Vector</a> or <a class="el" href="classmathter_1_1_matrix.html">Matrix</a> dimension template parameter to set size at runtime. PLEASE NOTE THAT DYNAMICALLY SIZED VECTORS AND MATRICES ARE NOT SUPPORTED YET. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
